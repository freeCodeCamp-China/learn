{
  "name": "ES6",
  "order": 2,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "587d7b87367417b2b2512b3f",
      "title": "Explore Differences Between the var and let Keywords",
      "description": [
        "使用<code>var</code>关键字来声明变量，会出现重复声明导致变量被覆盖却不会报错的问题：",
        "<blockquote>var camper = 'James';<br>var camper = 'David';<br>console.log(camper);<br>// 打印出 'David'</blockquote>",
        "在上面的代码中，<code>camper</code>的初始值为<code>'James'</code>，然后又被覆盖成了<code>'David'</code>。",
        "在小型的应用中，你可能不会遇到这样的问题，但是当你的代码规模变得更加庞大的时候，就可能会在不经意间覆盖了之前定义的变量。",
        "这样的行为不会报错，导致了 debug 非常困难。<br>",
        "在 ES6 中引入了新的关键字<code>let</code>来解决<code>var</code>关键字带来的潜在问题。",
        "如果你在上面的代码中，使用了<code>let</code>关键字来代替<code>var</code>关键字，结果会是一个报错。",
        "<blockquote>let camper = 'James';<br>let camper = 'David'; // 报错</blockquote>",
        "你可以在浏览器的控制台里看见这个错误。",
        "与<code>var</code>不同的是，当使用<code>let</code>的时候，同一名字的变量只能被声明一次。",
        "请注意<code>\"use strict\"</code>。这代表着开启了严格模式，用于检测常见的代码错误以及\"不安全\"的行为，例如：",
        "<blockquote>\"use strict\";<br>x = 3.14; // x 没有声明导致了报错</blockquote>",
        "<hr>",
        "请更新这段代码，并且在其中只使用<code>let</code>关键字"
      ],
      "tests": [
        {
          "text": "在代码中不应存在<code>var</code>。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g),'在代码中不应存在<code>var</code>。');"
        },
        {
          "text": "<code>catName</code>变量的值应该为<code>\"Oliver\"</code>。",
          "testString": "assert(catName === \"Oliver\", '<code><code>catName</code>变量的值应该为<code>\"Oliver\"</code>。');"
        },
        {
          "text": "<code>quote</code>变量的值应该为<code>\"Oliver says Meow!\"</code>",
          "testString": "assert(quote === \"Oliver says Meow!\", '<code>quote</code>变量的值应该为<code>\"Oliver says Meow!\"</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var catName;",
            "var quote;",
            "function catTalk() {",
            "  \"use strict\";",
            "",
            "  catName = \"Oliver\";",
            "  quote = catName + \" says Meow!\";",
            "",
            "}",
            "catTalk();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b87367417b2b2512b40",
      "title": "Compare Scopes of the var and let Keywords",
      "description": [
        "当你使用<code>var</code>关键字来声明一个变量的时候，这个变量会被声明成全局变量，或是函数内的局部变量。",
        "<code>let</code>关键字的作用类似，但会有一些额外的特性。如果你在代码块、语句或表达式中使用关键字<code>let</code>声明变量，这个变量的作用域就被限制在当前的代码块，语句或表达式之中。",
        "举个例子：",
        "<blockquote>var numArray = [];<br>for (var i = 0; i < 3; i++) {<br>&nbsp;&nbsp;numArray.push(i);<br>}<br>console.log(numArray);<br>// 返回 [0, 1, 2]<br>console.log(i);<br>// 返回 3</blockquote>",
        "当使用<code>var</code>关键字的时候，<code>i</code>会被声明成全局变量。当<code>i++</code>执行的时候，它会改变全局变量的值。这段代码可以看做下面这样:",
        "<blockquote>var numArray = [];<br>var i;<br>for (i = 0; i < 3; i++) {<br>&nbsp;&nbsp;numArray.push(i);<br>}<br>console.log(numArray);<br>// returns [0, 1, 2]<br>console.log(i);<br>// returns 3</blockquote>",
        "如果你在<code>for</code>循环中创建了使用<code>i</code>变量的函数，那么在后续调用函数的时候，上面提到的这种行为就会导致问题。这是因为函数存储的值会因为全局变量<code>i</code>的变化而不断的改变。",
        "<blockquote>var printNumTwo;<br>for (var i = 0; i < 3; i++) {<br>&nbsp;&nbsp;if(i === 2){<br>&nbsp;&nbsp;&nbsp;&nbsp;printNumTwo = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;}<br>}<br>console.log(printNumTwo());<br>// 返回 3</blockquote>",
        "可以看到，<code>printNumTwo()</code>打印了 3 而不是 2。这是因为<code>i</code>发生了改变，并且函数<code>printNumTwo()</code>返回的是全局变量<code>i</code>的值，而不是<code>for</code>循环中创建函数时<code>i</code>的值。<code>let</code>关键字就不会有这种现象：",
        "<blockquote>'use strict';<br>let printNumTwo;<br>for (let i = 0; i < 3; i++) {<br>&nbsp;&nbsp;if (i === 2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;printNumTwo = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;}<br>}<br>console.log(printNumTwo());<br>// 返回 2<br>console.log(i);<br>// 返回 \"没有定义 i 变量\"</blockquote>",
        "<code>i</code>在全局作用域中没有声明，所以它没有被定义，它的声明只会发生在<code>for</code>循环内。在循环执行的时候，<code>let</code>关键字创建了三个不同的<code>i</code>变量，他们的值分别为 0、1 和 2，所以<code>printNumTwo()</code>返回了正确的值。",
        "<hr>",
        "修改这段代码，使得在<code>if</code>语句中声明的<code>i</code>变量与在函数的第一行声明的<code>i</code>变量是彼此独立的。请注意不要在你的代码的任何地方使用<code>var</code>关键字。",
        "这个练习说明了使用<code>var</code>与<code>let</code>关键字声明变量时，作用域之间的不同。当编写类似这个练习中的函数的时候，通常来说最好还是使用不同的变量名来避免误会。"
      ],
      "tests": [
        {
          "text": "<code>var</code>不应该在代码中存在。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g),'<code>var</code>不应该在代码中存在。');"
        },
        {
          "text": "在<code>if</code>语句中声明的<code>i</code>变量的值是 \"block scope\"。",
          "testString": "getUserInput => assert(getUserInput('index').match(/(i\\s*=\\s*).*\\s*.*\\s*.*\\1('|\")block\\s*scope\\2/g), '在<code>if</code>语句中声明的<code>i</code>变量应该是 \"block scope\"。');"
        },
        {
          "text": "<code>checkScope()</code>应当返回 \"function scope\"",
          "testString": "assert(checkScope() === \"function scope\", '<code>checkScope()</code>应该返回 \"function scope\"');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkScope() {",
            "\"use strict\";",
            "  var i = \"function scope\";",
            "  if (true) {",
            "    i = \"block scope\";",
            "    console.log(\"Block scope i is: \", i);",
            "  }",
            "  console.log(\"Function scope i is: \", i);",
            "  return i;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b87367417b2b2512b41",
      "title": "Declare a Read-Only Variable with the const Keyword",
      "description": [
        "<code>let</code>并不是唯一的新的声明变量的方式。在 ES6里面，你还可以使用<code>const</code>关键字来声明变量。",
        "<code>const</code>拥有<code>let</code>的所有优点，所不同的是，通过<code>const</code>声明的变量是只读的。这意味着通过<code>const</code>声明的变量只能被赋值一次，而不能被再次赋值。",
        "<blockquote>\"use strict\"<br>const FAV_PET = \"Cats\";<br>FAV_PET = \"Dogs\"; // 报错 </blockquote>",
        "可以看见，尝试给通过<code>const</code>声明的变量再次赋值会报错。你应该使用<code>const</code>关键字来对所有不打算再次赋值的变量进行声明。这有助于你避免给一个常量进行额外的再次赋值。一个最佳实践是对所有常量的命名采用全大写字母，并在单词之间使用下划线进行分隔。",
        "<hr>",
        "改变以下代码，使得所有的变量都使用<code>let</code>或<code>const</code>关键词来声明。当变量将会改变的时候使用<code>let</code>关键字，当变量要保持常量的时候使用<code>const</code>关键字。同时，对使用<code>const</code>声明的变量进行最佳实践的重命名，变量名中的字母应该都是大写的。"
      ],
      "tests": [
        {
          "text": "<code>var</code>在代码中不存在。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g),'<code>var</code>在代码中不存在。');"
        },
        {
          "text": "<code>SENTENCE</code>应该是使用<code>const</code>声明的常量。",
          "testString": "getUserInput => assert(getUserInput('index').match(/(const SENTENCE)/g), '<code>SENTENCE</code>应该是使用<code>const</code>声明的常量。');"
        },
        {
          "text": "<code>i</code>应该是使用<code>let</code>声明的变量。",
          "testString": "getUserInput => assert(getUserInput('index').match(/(let i)/g), '<code>i</code>应该是使用<code>let</code>声明的变量。');"
        },
        {
          "text": "<code>console.log</code>应该修改为用于打印<code>SENTENCE</code>变量。",
          "testString": "getUserInput => assert(getUserInput('index').match(/console\\.log\\(\\s*SENTENCE\\s*\\)\\s*;?/g), '<code>console.log</code>应该修改为用于打印<code>SENTENCE</code>变量。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function printManyTimes(str) {",
            "  \"use strict\";",
            "",
            "  // 在这行以下修改代码",
            "",
            "  var sentence = str + \" is cool!\";",
            "  for(var i = 0; i < str.length; i+=2) {",
            "    console.log(sentence);",
            "  }",
            "",
            "  // 在这行以上修改代码",
            "",
            "}",
            "printManyTimes(\"freeCodeCamp\");"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b87367417b2b2512b42",
      "title": "Mutate an Array Declared with const",
      "description": [
        "在现代的 JavaScript 里，<code>const</code>声明有很多用法。",
        "一些开发者倾向默认使用<code>const</code>来声明所有变量，但如果它们打算在后续的代码中修改某个值，那在声明的时候就会用<code>let</code>。",
        "然而，你要注意，对象（包括数组和函数）在使用<code>const</code>声明的时候依然是可变的。使用<code>const</code>来声明只会保证它的标识不会被重新赋值。",
        "<blockquote>\"use strict\";<br>const s = [5, 6, 7];<br>s = [1, 2, 3]; // 试图给 const 变量赋值，报错<br>s[2] = 45; // 与用 var 或 let 声明的数组一样，这个操作也会成功<br>console.log(s); // 返回 [5, 6, 45]</blockquote>",
        "从以上代码看出，你可以改变<code>[5, 6, 7]</code>自身，所以<code>s</code>变量指向了改变后的数组<code>[5, 6, 45]</code>。和所有数组一样，数组<code>s</code>中的数组元素是可以被改变的，但是因为使用了<code>const</code>关键字，你不能使用赋值操作符将变量标识<code>s</code>指向另外一个数组。",
        "<hr>",
        "这里有一个使用<code>const s = [5, 7, 2]</code>声明的数组。使用对各元素赋值的方法将数组改成<code>[2, 5, 7]</code>。"
      ],
      "tests": [
        {
          "text": "不要替换<code>const</code>关键字。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const/g), '不要替换<code>const</code>关键字。');"
        },
        {
          "text": "<code>s</code>应该为常量 (通过使用<code>const</code>)。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+s/g), '<code>s</code>应该为常量 (通过使用<code>const</code>)。');"
        },
        {
          "text": "不要改变原数组的声明。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+s\\s*=\\s*\\[\\s*5\\s*,\\s*7\\s*,\\s*2\\s*\\]\\s*;?/g), '不要改变原数组的声明。');"
        },
        {
          "text": "<code>s</code>应该等于<code>[2, 5, 7]</code>。",
          "testString": "assert.deepEqual(s, [2, 5, 7], '<code>s</code>应该等于<code>[2, 5, 7]</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const s = [5, 7, 2];",
            "function editInPlace() {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "",
            "  // s = [2, 5, 7]; <- this is invalid",
            "",
            "  // 在这行以上修改代码",
            "}",
            "editInPlace();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "598f48a36c8c40764b4e52b3",
      "title": "Prevent Object Mutation",
      "description": [
        "通过之前的挑战可以看出,<code>const</code>声明并不会真的保护你的数据不被改变。为了确保数据不被改变，JavaScript 提供了一个函数<code>Object.freeze</code>来防止数据改变。",
        "当一个对象被冻结的时候，你不能再对它的属性再进行增、删、改的操作。任何试图改变对象的操作都会被阻止，却不会报错。",
        "<blockquote>let obj = {<br>&nbsp;&nbsp;name:\"FreeCodeCamp\",<br>&nbsp;&nbsp;review:\"Awesome\"<br>};<br>Object.freeze(obj);<br>obj.review = \"bad\"; // obj 对象被冻结了，这个操作会被忽略<br>obj.newProp = \"Test\"; // 也会被忽略，不允许数据改变<br>console.log(obj); <br>// { name: \"FreeCodeCamp\", review:\"Awesome\"}</blockquote>",
        "<hr>",
        "在这个挑战中，你将使用<code>Object.freeze</code>来防止数学常量被改变。你需要冻结<code>MATH_CONSTANTS</code>对象，使得没有人可以改变<code>PI</code>的值，抑或增加或删除属性。"
      ],
      "tests": [
        {
          "text": "不要替换<code>const</code>关键字。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const/g), '不要替换<code>const</code>关键字。');"
        },
        {
          "text": "<code>MATH_CONSTANTS</code>应该为一个常量 (使用<code>const</code>)。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+MATH_CONSTANTS/g), '<code>MATH_CONSTANTS</code>应该为一个常量 (使用<code>const</code>)。');"
        },
        {
          "text": "不要改变原始的<code>MATH_CONSTANTS</code>。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+MATH_CONSTANTS\\s+=\\s+{\\s+PI:\\s+3.14\\s+};/g), '不要改变原始的<code>MATH_CONSTANTS</code>。');"
        },
        {
          "text": "<code>PI</code>等于<code>3.14</code>。",
          "testString": "assert(PI === 3.14, '<code>PI</code>等于<code>3.14</code>。');"
        }
      ],
      "releasedOn": "Aug 12, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function freezeObj() {",
            "  \"use strict\";",
            "  const MATH_CONSTANTS = {",
            "    PI: 3.14",
            "  };",
            "  // 在这行以下修改代码",
            "",
            "",
            "  // 在这行以上修改代码",
            "  try {",
            "    MATH_CONSTANTS.PI = 99;",
            "  } catch( ex ) {",
            "    console.log(ex);",
            "  }",
            "  return MATH_CONSTANTS.PI;",
            "}",
            "const PI = freezeObj();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b87367417b2b2512b43",
      "title": "Use Arrow Functions to Write Concise Anonymous Functions",
      "description": [
        "在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。这时，我们会创建匿名函数。因为这些函数不会在其他地方复用，所以我们不需要给它们命名。",
        "这种情况下，我们通常会使用以下语法：",
        "<blockquote>const myFunc = function() {<br>&nbsp;&nbsp;const myVar = \"value\";<br>&nbsp;&nbsp;return myVar;<br>}</blockquote>",
        "ES6 提供了其他写匿名函数的方式的语法糖。你可以使用箭头函数：",
        "<blockquote>const myFunc = () => {<br>&nbsp;&nbsp;const myVar = \"value\";<br>&nbsp;&nbsp;return myVar;<br>}</blockquote>",
        "当不需要函数体，只返回一个值的时候，箭头函数允许你省略<code>return</code>关键字和外面的大括号。这样就可以将一个简单的函数简化成一个单行语句。",
        "<blockquote>const myFunc= () => \"value\"</blockquote>",
        "这段代码仍然会返回<code>value</code>。",
        "<hr>",
        "使用箭头函数的语法重写<code>magic</code>函数，使其返回一个新的<code>Date()</code>。同时不要用<code>var</code>关键字来定义任何变量。"
      ],
      "tests": [
        {
          "text": "替换掉<code>var</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g), '替换掉<code>var</code>关键字。');"
        },
        {
          "text": "<code>magic</code>应该为一个常量 (使用<code>const</code>)。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+magic/g), '<code>magic</code>应该为一个常量 (使用<code>const</code>)。');"
        },
        {
          "text": "<code>magic</code>是一个<code>function</code>。",
          "testString": "assert(typeof magic === 'function', '<code>magic</code>是一个<code>function</code>。');"
        },
        {
          "text": "<code>magic()</code>返回正确的日期。",
          "testString": "assert(magic().getDate() == new Date().getDate(), '<code>magic()</code>返回正确的日期。');"
        },
        {
          "text": "不要使用<code>function</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/function/g), '不要使用<code>function</code>关键字。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var magic = function() {",
            "  \"use strict\";",
            "  return new Date();",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b88367417b2b2512b44",
      "title": "Write Arrow Functions with Parameters",
      "description": [
        "和一般的函数一样，你也可以给箭头函数传递参数。",
        "<blockquote>// 给传入的数值乘以 2 并返回结果<br>const doubler = (item) => item * 2;</blockquote>",
        "你同样可以给箭头函数传递多个参数。",
        "<hr>",
        "使用箭头函数的语法重写<code>myConcat</code>函数，使其可以将<code>arr2</code>的内容填充在<code>arr1</code>里。"
      ],
      "tests": [
        {
          "text": "替换掉所有的<code>var</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g), '替换掉所有的<code>var</code>关键字。');"
        },
        {
          "text": "<code>myConcat</code>应该是一个常量 (使用<code>const</code>)。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+myConcat/g), '<code>myConcat</code>应该是一个常量 (使用<code>const</code>)。');"
        },
        {
          "text": "<code>myConcat</code>应该是一个函数。",
          "testString": "assert(typeof myConcat === 'function', '<code>myConcat</code>应该是一个函数。');"
        },
        {
          "text": "<code>myConcat()</code>返回正确的<code>array</code>。",
          "testString": "assert(() => { const a = myConcat([1], [2]); return a[0] == 1 && a[1] == 2; }, '<code>myConcat()</code>返回正确的<code>array</code>。');"
        },
        {
          "text": "不要使用<code>function</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/function/g), '不要使用<code>function</code>关键字。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var myConcat = function(arr1, arr2) {",
            "  \"use strict\";",
            "  return arr1.concat(arr2);",
            "};",
            "// 测试你的代码",
            "console.log(myConcat([1, 2], [3, 4, 5]));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b88367417b2b2512b45",
      "title": "Write Higher Order Arrow Functions",
      "description": [
        "我们已经见识到了箭头函数在处理数据时候的强大之处。",
        "箭头函数在类似<code>map()</code>，<code>filter()</code>，<code>reduce()</code>等需要其他函数作为参数来处理数据的高阶函数里会很好用。" ,
        "阅读以下代码：",
        "<blockquote>FBPosts.filter(function(post) {<br>&nbsp;&nbsp;return post.thumbnail !== null && post.shares > 100 && post.likes > 500;<br>})</blockquote>",
        "我们写下了<code>filter</code>函数，并尽量保证可读性。现在让我们用箭头函数来写同样的代码看看：",
        "<blockquote>FBPosts.filter((post) => post.thumbnail !== null && post.shares > 100 && post.likes > 500)</blockquote>",
        "这段代码完成了同样的任务，却变得更加简短易懂了。",
        "<hr>",
        "使用箭头函数的语法来计算<code>squaredIntegers</code>数组里正整数的平方（分数不是整数）。"
      ],
      "tests": [
        {
          "text": "替换掉所有的<code>var</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/var/g), '替换掉所有的<code>var</code>关键字。');"
        },
        {
          "text": "<code>squaredIntegers</code>应该是一个常量 (使用<code>const</code>)。",
          "testString": "getUserInput => assert(getUserInput('index').match(/const\\s+squaredIntegers/g), '<code>squaredIntegers</code>应该是一个常量 (使用<code>const</code>)。');"
        },
        {
          "text": "<code>squaredIntegers</code>应该是一个<code>array</code>。",
          "testString": "assert(Array.isArray(squaredIntegers), '<code>squaredIntegers</code>应该是一个<code>array</code>');"
        },
        {
          "text": "<code>squaredIntegers</code> 应该是<code>[16, 1764, 36]</code>",
          "testString": "assert(squaredIntegers[0] === 16 && squaredIntegers[1] === 1764 && squaredIntegers[2] === 36, '<code>squaredIntegers</code> 应该是<code>[16, 1764, 36]</code>');"
        },
        {
          "text": "不要使用<code>function</code>关键字。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/function/g), '不要使用<code>function</code>关键字。');"
        },
        {
          "text": "不要使用循环",
          "testString": "getUserInput => assert(!getUserInput('index').match(/(for)|(while)/g), '不要使用循环');"
        },
        {
          "text": "请使用<code>map</code>,<code>filter</code>, 或者<code>reduce</code>。",
          "testString": "getUserInput => assert(getUserInput('index').match(/map|filter|reduce/g), '请使用<code>map</code>,<code>filter</code>, 或者<code>reduce</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const realNumberArray = [4, 5.6, -9.8, 3.14, 42, 6, 8.34];",
            "const squareList = (arr) => {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "  const squaredIntegers = arr;",
            "  // 在这行以上修改代码",
            "  return squaredIntegers;",
            "};",
            "// 测试你的代码",
            "const squaredIntegers = squareList(realNumberArray);",
            "console.log(squaredIntegers);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b88367417b2b2512b46",
      "title": "Set Default Parameters for Your Functions",
      "description": [
        "ES6 里允许给函数传入<dfn>默认参数</dfn>，来构建更加灵活的函数。",
        "请看以下代码：",
        "<blockquote>function greeting(name = \"Anonymous\") {<br>&nbsp;&nbsp;return \"Hello \" + name;<br>}<br>console.log(greeting(\"John\")); // Hello John<br>console.log(greeting()); // Hello Anonymous</blockquote>",
        "默认参数会在参数没有被指定（值为 undefined ）的时候起作用。在上面的例子中，参数<code>name</code>会在没有得到新的值的时候，默认使用值 \"Anonymous\"。你还可以给多个参数赋予默认值。",
        "<hr>",
        "给函数<code>increment</code>加上默认参数，使得在<code>value</code>没有被赋值的时候，默认给<code>number</code>加1。"
      ],
      "tests": [
        {
          "text": "<code>increment(5, 2)</code>的结果应该为<code>7</code>。",
          "testString": "assert(increment(5, 2) === 7, '<code>increment(5, 2)</code>的结果应该为<code>7</code>。');"
        },
        {
          "text": "<code>increment(5)</code>的结果应该为<code>6</code>。",
          "testString": "assert(increment(5) === 6, '<code>increment(5)</code>的结果应该为<code>6</code>。');"
        },
        {
          "text": "参数<code>value</code>的默认值应该为<code>1</code>。",
          "testString": "getUserInput => assert(getUserInput('index').match(/value\\s*=\\s*1/g), 'default parameter<code>1</code>was used for<code>value</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const increment = (function() {",
            "  \"use strict\";",
            "  return function increment(number, value) {",
            "    return number + value;",
            "  };",
            "})();",
            "console.log(increment(5, 2)); // 返回 7",
            "console.log(increment(5)); // 返回 6"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b88367417b2b2512b47",
      "title": "Use the Rest Operator with Function Parameters",
      "description": [
        "ES6 推出了用于函数参数的<dfn> rest 操作符</dfn>帮助我们创建更加灵活的函数。在<code>rest</code>操作符的帮助下，你可以创建有一个变量来接受多个参数的函数。这些参数被储存在一个可以在函数内部读取的数组中。",
        "请看以下代码：",
        "<blockquote>function howMany(...args) {<br>&nbsp;&nbsp;return \"You have passed \" + args.length + \" arguments.\";<br>}<br>console.log(howMany(0, 1, 2)); // 输出：You have passed 3 arguments.<br>console.log(howMany(\"string\", null, [1, 2, 3], { })); // 输出：You have passed 4 arguments.</blockquote>",
        "<code>rest</code>操作符可以避免查看<code>args</code>数组的需求，并且允许我们在参数数组上使用<code>map()</code>,<code>fiter()</code>，和<code>reduce()</code>。",
        "<hr>",
        "修改<code>sum</code>函数，来让它使用<code>rest</code>操作符，并且它可以在有任何数量的参数时以相同的形式工作。"
      ],
      "tests": [
        {
          "text": "<code>sum(0,1,2)</code>的返回结果应该为3。",
          "testString": "assert(sum(0,1,2) === 3, '<code>sum(0,1,2)</code>的返回结果应该为3。');"
        },
        {
          "text": "<code>sum(1,2,3,4)</code>的返回结果应该为10。",
          "testString": "assert(sum(1,2,3,4) === 10, '<code>sum(1,2,3,4)</code>的返回结果应该为10。');"
        },
        {
          "text": "<code>sum(5)</code>的返回结果应该为5。",
          "testString": "assert(sum(5) === 5, '<code>sum(5)</code>的返回结果应该为5。');"
        },
        {
          "text": "<code>sum()</code>的返回结果应该为 0。",
          "testString": "assert(sum() === 0, '<code>sum()</code>的返回结果应该为 0。');"
        },
        {
          "text": "对<code>sum</code>函数的<code>args</code>参数使用了<code>...</code>展开操作符。",
          "testString": "getUserInput => assert(getUserInput('index').match(/function\\s+sum\\s*\\(\\s*...args\\s*\\)\\s*{/g), '对<code>sum</code>函数的<code>args</code>参数使用了<code>...</code>展开操作符。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const sum = (function() {",
            "  \"use strict\";",
            "  return function sum(x, y, z) {",
            "    const args = [ x, y, z ];",
            "    return args.reduce((a, b) => a + b, 0);",
            "  };",
            "})();",
            "console.log(sum(1, 2, 3)); // 6"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b89367417b2b2512b48",
      "title": "Use the Spread Operator to Evaluate Arrays In-Place",
      "description": [
        "ES6 允许我们使用 <dfn>展开操作符</dfn> 来展开数组，以及需要多个参数或元素的表达式。",
        "下面的 ES5 代码使用了<code>apply()</code>来计算数组的最大值：",
        "<blockquote>var arr = [6, 89, 3, 45];<br>var maximus = Math.max.apply(null, arr); // 返回 89</blockquote>",
        "我们必须使用<code>Math.max.apply(null,arr)</code>，是因为直接调用<code>Math.max(arr)</code>会返回<code>NaN</code>。<code>Math.max()</code>函数需要传入的是一系列由逗号分隔的参数，而不是一个数组。",
        "展开操作符可以提升代码的可读性，这对后续的代码维护是有积极作用的。",
        "<blockquote>const arr = [6, 89, 3, 45];<br>const maximus = Math.max(...arr); // 返回 89</blockquote>",
        "<code>...arr</code>返回了一个“打开”的数组。或者说它 <em>展开</em> 了数组。",
        "然而，展开操作符只能够在函数的参数中，或者数组之中使用。下面的代码将会报错：",
        "<blockquote>const spreaded = ...arr; // 将会发生语法错误</blockquote>",
        "<hr>",
        "使用展开操作符将<code>arr1</code>中的内容都赋值到<code>arr2</code>中去。"
      ],
      "tests": [
        {
          "text": "<code>arr2</code>的值是由<code>arr1</code>拷贝而来的。",
          "testString": "assert(arr2.every((v, i) => v === arr1[i]), '<code>arr2</code>的值是由<code>arr1</code>拷贝而来的。');"
        },
        {
          "text": "用<code>...</code>展开操作符来赋值<code>arr1</code>。",
          "testString": "getUserInput => assert(getUserInput('index').match(/\\[\\s*...arr1\\s*\\]/g),'用<code>...</code>展开操作符来赋值<code>arr1</code>。');"
        },
        {
          "text": "当<code>arr1</code>改变的时候，<code>arr2</code>不会改变。",
          "testString": "assert((arr1, arr2) => {arr1.push('JUN'); return arr2.length < arr1.length},'当<code>arr1</code>改变的时候，<code>arr2</code>不会改变。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];",
            "let arr2;",
            "(function() {",
            "  \"use strict\";",
            "  arr2 = []; // 改变这一行",
            "})();",
            "console.log(arr2);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b89367417b2b2512b49",
      "title": "Use Destructuring Assignment to Assign Variables from Objects",
      "description": [
        "我们之前看到了展开操作符是如何展开数组的内容的。",
        "对于对象，我们也可以做同样的操作。<dfn>解构赋值</dfn> 就是可以从对象中直接获取对应值的语法。",
        "看看以下 ES5 的代码：",
        "<blockquote>var voxel = {x: 3.6, y: 7.4, z: 6.54 };<br>var x = voxel.x; // x = 3.6<br>var y = voxel.y; // y = 7.4<br>var z = voxel.z; // z = 6.54</blockquote>",
        "使用 ES6 的解构语法可以完成同样的赋值语句：",
        "<blockquote>const { x, y, z } = voxel; // x = 3.6, y = 7.4, z = 6.54</blockquote>",
        "如果你想将<code>voxel.x</code>,<code>voxel.y</code>,<code>voxel.z</code>的值分别赋给<code>a</code>,<code>b</code>,<code>c</code>，可以用以下这种很棒的方式：",
        "<blockquote>const { x : a, y : b, z : c } = voxel // a = 3.6, b = 7.4, c = 6.54</blockquote>",
        "你可以这样理解：“将<code>x</code>地址中的值拷贝到<code>a</code>当中去。”，等等。",
        "<hr>",
        "使用解构语法去得到输入的<code>str</code>字符串的长度，并将长度赋值给<code>len</code>。"
      ],
      "tests": [
        {
          "text": "函数<code>getLength()</code>返回一个数字。",
          "testString": "assert(typeof getLength('') === 'number', '函数<code>getLength()</code>返回一个数字。');"
        },
        {
          "text": "<code>getLength(\"FreeCodeCamp\")</code>应该返回<code>12</code>。",
          "testString": "assert(getLength(\"FreeCodeCamp\") === 12, '<code>getLength(\"FreeCodeCamp\")</code>应该返回<code>12</code>。');"
        },
        {
          "text": "使用解构语法来重新赋值。",
          "testString": "getUserInput => assert(getUserInput('index').match(/\\{\\s*length\\s*:\\s*len\\s*}\\s*=\\s*str/g),'使用解构语法来重新赋值。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function getLength(str) {",
            "  \"use strict\";",
            "",
            "  // 在这行以下修改代码",
            "  const length = 0; // change this",
            "  // 在这行以上修改代码",
            "",
            "  return len; // 你必须在这行将<code>length</code>赋值给<code>len</code>",
            "",
            "}",
            "",
            "console.log(getLength('FreeCodeCamp'));"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b89367417b2b2512b4a",
      "title": "Use Destructuring Assignment to Assign Variables from Nested Objects",
      "description": [
        "同样，我们可以将 <em>嵌套的对象</em>解构到变量中。",
        "请看以下代码：",
        "<blockquote>const a = {<br>&nbsp;&nbsp;start: { x: 5, y: 6},<br>&nbsp;&nbsp;end: { x: 6, y: -9 }<br>};<br>const { start : { x: startX, y: startY }} = a;<br>console.log(startX, startY); // 5, 6</blockquote>",
        "在上面的例子里，<code>a.start</code>将值赋给了变量<code>start</code>，<code>start</code>同样也是个对象。",
        "<hr>",
        "使用解构赋值来得到<code>forecast.tomorrow</code>的<code>max</code>，并将其赋值给<code>maxOfTomorrow</code>。"
      ],
      "tests": [
        {
          "text": "<code>maxOfTomorrow</code>等于<code>84.6</code>",
          "testString": "assert(getMaxOfTmrw(LOCAL_FORECAST) === 84.6, '<code>maxOfTomorrow</code>等于<code>84.6</code>');"
        },
        {
          "text": "使用嵌套解构",
          "testString": "getUserInput => assert(getUserInput('index').match(/\\{\\s*tomorrow\\s*:\\s*\\{\\s*max\\s*:\\s*maxOfTomorrow\\s*\\}\\s*\\}\\s*=\\s*forecast/g),'使用嵌套解构');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const LOCAL_FORECAST = {",
            "  today: { min: 72, max: 83 },",
            "  tomorrow: { min: 73.3, max: 84.6 }",
            "};",
            "",
            "function getMaxOfTmrw(forecast) {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "  const maxOfTomorrow = undefined; // 改变这一行",
            "  // 在这行以上修改代码",
            "  return maxOfTomorrow;",
            "}",
            "",
            "console.log(getMaxOfTmrw(LOCAL_FORECAST)); // 应该为 84.6"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b89367417b2b2512b4b",
      "title": "Use Destructuring Assignment to Assign Variables from Arrays",
      "description": [
        "在 ES6 里面，解构数组可以如同解构对象一样简单。",
        "与数组解构不同，数组的扩展运算会将数组里的所有内容分解成一个由逗号分隔的列表。所以，你不能选择哪个元素来给变量赋值。",
        "而对数组进行解构却可以让我们做到这一点：",
        "<blockquote>const [a, b] = [1, 2, 3, 4, 5, 6];<br>console.log(a, b); // 1, 2</blockquote>",
        "变量<code>a</code>以及<code>b</code>分别被数组的第一、第二个元素赋值。",
        "我们甚至能在数组解构中使用逗号分隔符，来获取任意一个想要的值：",
        "<blockquote>const [a, b,,, c] = [1, 2, 3, 4, 5, 6];<br>console.log(a, b, c); // 1, 2, 5 </blockquote>",
        "<hr>",
        "使用数组解构来交换变量<code>a</code>与<code>b</code>的值。使<code>a</code>、<code>b</code>能分别获得对方的值。"
      ],
      "tests": [
        {
          "text": "在交换后，<code>a</code>的值应该为6。",
          "testString": "assert(a === 6, '在交换后，<code>a</code>的值应该为6。');"
        },
        {
          "text": "在交换后，<code>b</code>的值应该为8。",
          "testString": "assert(b === 8, '在交换后，<code>b</code>的值应该为8。');"
        },
        {
          "text": "使用数组解构来交换<code>a</code>和<code>b</code>。",
          "testString": "// assert(/\\[\\s*(\\w)\\s*,\\s*(\\w)\\s*\\]\\s*=\\s*\\[\\s*\\2\\s*,\\s*\\1\\s*\\]/g.test(code), '使用数组解构来交换<code>a</code>和<code>b</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "let a = 8, b = 6;",
            "(() => {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "  ",
            "  // 在这行以上修改代码",
            "})();",
            "console.log(a); // 应该等于 6",
            "console.log(b); // 应该等于 8"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8a367417b2b2512b4c",
      "title": "Use Destructuring Assignment with the Rest Operator to Reassign Array Elements",
      "description": [
        "在解构数组的某些情况下，我们可能希望将剩下的元素放进另一个数组里面。",
        "以下代码的结果与使用<code>Array.prototype.slice()</code>相同：",
        "<blockquote>const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];<br>console.log(a, b); // 1, 2<br>console.log(arr); // [3, 4, 5, 7]</blockquote>",
        "变量<code>a</code>与<code>b</code>分别获取了数组的前两个元素的值。之后，因为<code>rest</code>操作符的存在，<code>arr</code>获取了原数组剩余的元素的值，并构成了一个新的数组。",
        "<code>rest</code>操作只能对数组列表最后的元素起作用。这意味着你不能使用<code>rest</code>操作符来截取原数组中间元素的子数组。",
        "<hr>",
        "使用解构赋值以及<code>rest</code>操作符来进行一个<code>Array.prototype.slice</code>相同的操作。使得<code>arr</code>是原数组<code>source</code>除开前两个元素的子数组。"
      ],
      "tests": [
        {
          "text": "<code>arr</code>应该为<code>[3,4,5,6,7,8,9,10]</code>",
          "testString": "assert(arr.every((v, i) => v === i + 3),'<code>arr</code>应该为<code>[3,4,5,6,7,8,9,10]</code>');"
        },
        {
          "text": "使用了解构赋值。",
          "testString": "getUserInput => assert(getUserInput('index').match(/\\[\\s*\\w*\\s*,\\s*\\w*\\s*,\\s*...arr\\s*\\]/g),'使用了解构赋值。');"
        },
        {
          "text": "没有使用<code>Array.slice()</code>。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/Array.slice/g), '没有使用<code>Array.slice()</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const source = [1,2,3,4,5,6,7,8,9,10];",
            "function removeFirstTwo(list) {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "  arr = list; // change this",
            "  // 在这行以上修改代码",
            "  return arr;",
            "}",
            "const arr = removeFirstTwo(source);",
            "console.log(arr); // 应该为 [3,4,5,6,7,8,9,10]",
            "console.log(source); // 应该为 [1,2,3,4,5,6,7,8,9,10];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8a367417b2b2512b4d",
      "title": "Use Destructuring Assignment to Pass an Object as a Function's Parameters",
      "description": [
        "在某些情况下，你可以在函数的参数里直接解构对象。",
        "请看以下代码：",
        "<blockquote>const profileUpdate = (profileData) => {<br>&nbsp;&nbsp;const { name, age, nationality, location } = profileData;<br>&nbsp;&nbsp;// 对这些变量执行某些操作<br>}</blockquote>",
        "上面的操作解构了传给函数的对象。这样的操作也可以直接在参数里完成：",
        "<blockquote>const profileUpdate = ({ name, age, nationality, location }) => {<br>&nbsp;&nbsp;/* 对这些参数执行某些操作 */<br>}</blockquote>",
        "这样的操作去除了多余的代码，使代码更加整洁。",
        "这样做还有个额外的好处：函数不需要再去操作整个对象，而仅仅是操作复制到函数作用域内部的参数。",
        "<hr>",
        "对<code>half</code>的参数进行解构赋值，使得仅仅将<code>max</code>与<code>min</code>的值传进函数。"
      ],
      "tests": [
        {
          "text": "<code>stats</code>的类型应该是一个<code>object</code>。",
          "testString": "assert(typeof stats === 'object', '<code>stats</code>的类型应该是一个<code>object</code>。');"
        },
        {
          "text": "<code>half(stats)</code>应该等于<code>28.015</code>",
          "testString": "assert(half(stats) === 28.015, '<code>half(stats)</code>应该等于<code>28.015</code>');"
        },
        {
          "text": "使用了解构赋值。",
          "testString": "getUserInput => assert(getUserInput('index').match(/\\(\\s*\\{\\s*\\w+\\s*,\\s*\\w+\\s*\\}\\s*\\)/g), '使用了解构赋值。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const stats = {",
            "  max: 56.78,",
            "  standard_deviation: 4.34,",
            "  median: 34.54,",
            "  mode: 23.87,",
            "  min: -0.75,",
            "  average: 35.85",
            "};",
            "const half = (function() {",
            "  \"use strict\"; // 不要改变这行",
            "",
            "  // 在这行以下修改代码",
            "  return function half(stats) {",
            "    // 请在函数参数中使用解构赋值",
            "    return (stats.max + stats.min) / 2.0;",
            "  };",
            "  // 在这行以上修改代码",
            "",
            "})();",
            "console.log(stats); // 应该为 object",
            "console.log(half(stats)); // 应该为 28.015"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8a367417b2b2512b4e",
      "title": "Create Strings using Template Literals",
      "description": [
        "模板字符串是 ES6 的另外一项新的功能。这是一种可以轻松构建复杂字符串的方法。",
        "请看以下代码：",
        "<blockquote>const person = {<br>&nbsp;&nbsp;name: \"Zodiac Hasbro\",<br>&nbsp;&nbsp;age: 56<br>};<br><br>// string interpolation<br>const greeting = `Hello, my name is ${person.name}!<br>I am ${person.age} years old.`;<br><br>console.log(greeting); // 打印出<br>// Hello, my name is Zodiac Hasbro!<br>// I am 56 years old.<br></blockquote>",
        "这段代码有许多的不同：",
        "首先，上面使用的<code>${variable}</code>语法是一个占位符。这样一来，你将不再需要使用<code>+</code>运算符来连接字符串。当需要在字符串里增加变量的时候，你只需要在变量的外面括上<code>${</code>和<code>}</code>，并将其放在字符串里就可以了。",
        "其次，在例子使用了反引号（<code>`</code>），而不是引号（<code>'</code>或者<code>\"</code>）将字符串括了起来，并且这个字符串可以换行。",
        "这个新的方式使你可以更灵活的创建复杂的字符串。",
        "<hr>",
        "使用模板字符串的反引号的语法来展示<code>result</code>对象的<code>failure</code>数组内的每个条目。每个条目应该括在带有<code>text-warning</code>类属性的<code>li</code>标签中，并赋值给<code>resultDisplayArray</code>。"
      ],
      "tests": [
        {
          "text": "<code>resultDisplayArray</code> 是一个包含了 <code>result failure</code> 内的消息的数组。",
          "testString": "assert(typeof makeList(result.failure) === 'object' && resultDisplayArray.length === 3, '<code>resultDisplayArray</code> 是一个包含了 <code>result failure</code> 内的消息的数组。');"
        },
        {
          "text": "<code>resultDisplayArray</code> 要有正确的输出。",
          "testString": "assert(makeList(result.failure).every((v, i) => v === `<li class=\"text-warning\">${result.failure[i]}</li>`), '<code>resultDisplayArray</code> 要有正确的输出。');"
        },
        {
          "text": "应使用模板字符串。",
          "testString": "getUserInput => assert(getUserInput('index').match(/`.*`/g), '应使用模板字符串。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const result = {",
            "  success: [\"max-length\", \"no-amd\", \"prefer-arrow-functions\"],",
            "  failure: [\"no-var\", \"var-on-top\", \"linebreak\"],",
            "  skipped: [\"id-blacklist\", \"no-dup-keys\"]",
            "};",
            "function makeList(arr) {",
            "  \"use strict\";",
            "",
            "  // 在这行以下修改代码",
            "  const resultDisplayArray = null;",
            "  // 在这行以上修改代码",
            "",
            "  return resultDisplayArray;",
            "}",
            "/**",
            " * makeList(result.failure) 应该返回：",
            " * [ <li class=\"text-warning\">no-var</li>,",
            " *   <li class=\"text-warning\">var-on-top</li>, ",
            " *   <li class=\"text-warning\">linebreak</li> ]",
            " **/",
            "const resultDisplayArray = makeList(result.failure);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8a367417b2b2512b4f",
      "title": "Write Concise Object Literal Declarations Using Simple Fields",
      "description": [
        "ES6 添加了一些很棒的功能，以便于更方便地定义对象。",
        "请看以下代码：",
        "<blockquote>const getMousePosition = (x, y) => ({<br>&nbsp;&nbsp;x: x,<br>&nbsp;&nbsp;y: y<br>});</blockquote>",
        "<code>getMousePosition</code>是一个返回了拥有2个属性的对象的简单函数。",
        "ES6 提供了一个语法糖，消除了类似<code>x: x</code>这种冗余的写法.你可以仅仅只写一次<code>x<code>，解释器会自动将其转换成<code>x: x</code>。",
        "下面是使用这种语法重写的同样的函数：",
        "<blockquote>const getMousePosition = (x, y) => ({ x, y });</blockquote>",
        "<hr>",
        "请使用简单属性对象的语法来创建并返回一个<code>Person</code>对象。"
      ],
      "tests": [
        {
          "text": "输出是<code>{name: \"Zodiac Hasbro\", age: 56, gender: \"male\"}</code>。",
          "testString": "assert(() => {const res={name:\"Zodiac Hasbro\",age:56,gender:\"male\"}; const person=createPerson(\"Zodiac Hasbro\", 56, \"male\"); return Object.keys(person).every(k => person[k] === res[k]);}, '输出是<code>{name: \"Zodiac Hasbro\", age: 56, gender: \"male\"}</code>。');"
        },
        {
          "text": "不要使用<code>:</code>。",
          "testString": "getUserInput => assert(!getUserInput('index').match(/:/g), '不要使用<code>:</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const createPerson = (name, age, gender) => {",
            "  \"use strict\";",
            "  // 在这行以下修改代码",
            "  return {",
            "    name: name,",
            "    age: age,",
            "    gender: gender",
            "  };",
            "  // 在这行以上修改代码",
            "};",
            "console.log(createPerson(\"Zodiac Hasbro\", 56, \"male\")); // 返回正确的对象"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8b367417b2b2512b50",
      "title": "Write Concise Declarative Functions with ES6",
      "description": [
        "在 ES5 中，当我们需要在对象中定义一个函数的时候，我们必须如下面这般使用<code>function</code>关键字：",
        "<blockquote>const person = {<br>&nbsp;&nbsp;name: \"Taylor\",<br>&nbsp;&nbsp;sayHello: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return `Hello! My name is ${this.name}.`;<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "在 ES6 语法的对象中定义函数的时候，你可以完全删除<code>function</code>关键字和冒号。请看以下例子：",
        "<blockquote>const person = {<br>&nbsp;&nbsp;name: \"Taylor\",<br>&nbsp;&nbsp;sayHello() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return `Hello! My name is ${this.name}.`;<br>&nbsp;&nbsp;}<br>};</blockquote>",
        "<hr>",
        "使用以上这种简短的语法，重构在<code>bicycle</code>对象中的<code>setGear</code>函数。"
      ],
      "tests": [
        {
          "text": "不应使用<code>function</code>关键字定义方法。",
          "testString": "assert(!getUserInput('index').match(/function/), '不应使用<code>function</code>关键字定义方法。');"
        },
        {
          "text": "<code>setGear</code>应是一个函数。",
          "testString": "assert(typeof bicycle.setGear === 'function' && getUserInput('index').match(/setGear\\s*\\(.+\\)\\s*\\{/), '<code>setGear</code>应是一个函数。');"
        },
        {
          "text": "执行<code>bicycle.setGear(48)</code>应可以让<code>gear</code>的值变为 48。",
          "testString": "assert((new bicycle.setGear(48)).gear === 48, '执行<code>bicycle.setGear(48)</code>应可以让<code>gear</code>的值变为 48。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// 在这行以下修改代码",
            "const bicycle = {",
            "  gear: 2,",
            "  setGear: function(newGear) {",
            "    \"use strict\";",
            "    this.gear = newGear;",
            "  }",
            "};",
            "// 在这行以上修改代码",
            "bicycle.setGear(3);",
            "console.log(bicycle.gear);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8b367417b2b2512b53",
      "title": "Use class Syntax to Define a Constructor Function",
      "description": [
        "ES6 提供了一个新的创建对象的语法，使用关键字<code>class</code>。",
        "值得注意的是，<code>class</code>只是一个语法糖，它并不像 Java、Python 或者 Ruby 这一类的语言一样，严格履行了面向对象的开发规范。",
        "在 ES5 里面，我们通常会定义一个构造函数，然后使用 <code>new</code> 关键字来实例化一个对象：",
        "<blockquote>var SpaceShuttle = function(targetPlanet){<br>&nbsp;&nbsp;this.targetPlanet = targetPlanet;<br>}<br>var zeus = new SpaceShuttle('Jupiter');</blockquote>",
        "<code>class</code>的语法只是简单地替换了构造函数的写法：",
        "<blockquote>class SpaceShuttle {<br>&nbsp;&nbsp;constructor(targetPlanet){<br>&nbsp;&nbsp;&nbsp;&nbsp;this.targetPlanet = targetPlanet;<br>&nbsp;&nbsp;}<br>}<br>const zeus = new SpaceShuttle('Jupiter');</blockquote>",
        "注意<code>class</code>关键字声明了一个新的函数，并在其中添加了一个会在使用<code>new</code>关键字创建新对象时调用的构造函数。",
        "<hr>",
        "使用<code>class</code>关键字，并写出正确的构造函数，来创建<code>Vegetable</code>这个类：",
        "<code>Vegetable</code>这个类可以创建 vegetable 对象，这个对象拥有一个在构造函数中赋值的<code>name</code>属性。"
      ],
      "tests": [
        {
          "text": "<code>Vegetable</code> 应该是一个 <code>class</code>，并在其中定义了<code>constructor</code>方法。",
          "testString": "assert(typeof Vegetable === 'function' && typeof Vegetable.constructor === 'function', '<code>Vegetable</code> 应该是一个 <code>class</code>，并在其中定义了<code>constructor</code>方法。');"
        },
        {
          "text": "使用了<code>class</code>关键字。",
          "testString": "getUserInput => assert(getUserInput('index').match(/class/g),'使用了<code>class</code>关键字。');"
        },
        {
          "text": "<code>Vegetable</code>可以被实例化。",
          "testString": "assert(() => {const a = new Vegetable(\"apple\"); return typeof a === 'object';},'<code>Vegetable</code>可以被实例化。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function makeClass() {",
            "  \"use strict\";",
            "  /* 在这行下面改写代码 */",
            "",
            "  /* 在这行上面改写代码 */",
            "  return Vegetable;",
            "}",
            "const Vegetable = makeClass();",
            "const carrot = new Vegetable('carrot');",
            "console.log(carrot.name); // => 应该显示 'carrot'"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8c367417b2b2512b54",
      "title": "Use getters and setters to Control Access to an Object",
      "description": [
        "你可以从对象中获得一个值，也可以给对象的属性赋值。",
        "这些通常行为被称为 <dfn>getters</dfn> 以及 <dfn>setters</dfn>。",
        "Getter 函数的作用是可以让返回一个对象私有变量的值给用户，而不需要直接去访问私有变量。",
        "Setter 函数的作用是可以基于传进的参数来修改对象中私有变量的值。这些修改可以是计算，或者是直接替换之前的值。",
        "<blockquote>class Book {<br>&nbsp;&nbsp;constructor(author) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this._author = author;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;// getter<br>&nbsp;&nbsp;get writer(){<br>&nbsp;&nbsp;&nbsp;&nbsp;return this._author;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;// setter<br>&nbsp;&nbsp;set writer(updatedAuthor){<br>&nbsp;&nbsp;&nbsp;&nbsp;this._author = updatedAuthor;<br>&nbsp;&nbsp;}<br>}<br>const lol = new Book('anonymous');<br>console.log(lol.writer);&nbsp;&nbsp;// anonymous<br>lol.writer = 'wut';<br>console.log(lol.writer);&nbsp;&nbsp;// wut</blockquote>",
        "注意我们调用 getter 和 setter 的语法，它们看起来并不像一个函数调用。",
        "Getter 和 Setter 非常重要，因为它们隐藏了内部的实现细节。",
        "<hr>",
        "使用<code>class</code>关键字来创建<code>Thermostat</code>类，它的构造函数应该可以接收华氏温度作为参数。",
        "在类中创建 <code>getter</code>和<code>setter</code>，将温度转换成摄氏温度。",
        "温度转换的公式是<code>C = 5/9 * (F - 32)</code>以及<code>F = C * 9.0 / 5 + 32</code>，F 代表华氏温度，C 代表摄氏温度。",
        "请注意",
        "当你实现这个作业的时候，你应当在类中使用一个温度标准，无论是华氏温度还是摄氏温度。",
        "是时候展现 getter 和 setter 的威力了——无论你的 API 内部使用的是哪种温度标准，用户都能得到正确的结果。",
        "或者说，你从用户需求中抽象出了实现细节。"
      ],
      "tests": [
        {
          "text": "<code>Thermostat</code>应该是一个<code>class</code>，并且在其中定义了<code>constructor</code>方法。",
          "testString": "assert(typeof Thermostat === 'function' && typeof Thermostat.constructor === 'function','<code>Thermostat</code>应该是一个<code>class</code>，并且在其中定义了<code>constructor</code>方法。');"
        },
        {
          "text": "使用了<code>class</code>关键字。",
          "testString": "getUserInput => assert(getUserInput('index').match(/class/g),'使用了<code>class</code>关键字。');"
        },
        {
          "text": "<code>Thermostat</code>可以被实例化。",
          "testString": "assert(() => {const t = new Thermostat(32); return typeof t === 'object' && t.temperature === 0;}, '<code>Thermostat</code>可以被实例化。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function makeClass() {",
            "  \"use strict\";",
            "  /* 请把你的代码写在这条注释以下 */",
            "",
            "  /* 请把你的代码写在这条注释以上 */",
            "  return Thermostat;",
            "}",
            "const Thermostat = makeClass();",
            "const thermos = new Thermostat(76); // 使用华氏温度来初始化",
            "let temp = thermos.temperature; // 摄氏温度24.44度",
            "thermos.temperature = 26;",
            "temp = thermos.temperature; // 摄氏温度26度"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8c367417b2b2512b55",
      "title": "Understand the Differences Between import and require",
      "description": [
        "在过去，我们会使用<code>require()</code>函数来从外部文件或模块中引入函数或者代码。这时候会遇到一个问题：有些文件或者模块会特别大，但你却往往只需要引入其中的一些核心代码。",
        "ES6 给我们提供了<code>import</code>这个便利的工具。通过它，我们能够从外部的文件或者模块中选择我们需要的部分进行引入，从而节约载入的时间和内存空间。",
        "请看下面的例子：想象<code>math_array_functions</code>拥有大概20个函数，但是我只需要<code>countItems</code>这一个函数在我当前的文件里。使用老的<code>require()</code>方式会强制我引入所有20个函数。而使用新的<code>import</code>语法，我可以只引入需要的那个函数：",
        "<blockquote>import { countItems } from \"math_array_functions\"</blockquote>",
        "下面是对于上面代码的语义描述：",
        "<blockquote>import { function } from \"file_path_goes_here\"<br>// 我们还可以用同样的方式来引入变量！</blockquote>",
        "对<code>import</code>的使用，有许多的写法，但是上面的例子是最常用的写法。",
        "<strong>注意</strong><br>在大括号里的函数名的两侧加上空格是一个最佳实践——这可以帮助我们轻松的阅读<code>import</code>语句。",
        "<strong>注意</strong><br>本节课中进行的是一个非浏览器操作。<code>import</code>以及与其相关的在后面课程中的语句，是无法直接在浏览器上运行的。但是，我们可以通过一些工具来使它可以在浏览器中运行。",
        "<strong>注意</strong><br>在许多的例子中，在文件的路径前会加上<code>./</code>；否则， node.js 会先尝试去<code>node_modules</code>目录中寻找依赖项。",
        "<hr>",
        "添加正确的<code>import</code>语句，允许当前文件使用<code>capitalizeString</code>函数。这个函数是在与当前文件同一目录下的<code>\"string_functions\"</code>文件中声明的。"
      ],
      "tests": [
        {
          "text": "有效的<code>import</code>语句。",
          "testString": "getUserInput => assert(getUserInput('index').match(/import\\s+\\{\\s*capitalizeString\\s*\\}\\s+from\\s+(\"|')string_functions\\1/g), '有效的<code>import</code>语句。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "\"use strict\";",
            "capitalizeString(\"hello!\");"
          ],
          "head": [
            "window.require = function (str) {",
            "if (str === 'string_functions') {",
            "return {",
            "capitalizeString: str => str.toUpperCase()",
            "}}};"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8c367417b2b2512b56",
      "title": "Use export to Reuse a Code Block",
      "description": [
        "在上一个挑战中，你学习了关于<code>import</code>语句是如何从大文件中引入其中的部分代码的。但是，为了让其正常的工作，我们还必须了解一个与之相关的语句，叫做<code>export</code>。当我们想要一些代码——函数或者变量——在其他文件中使用，我们必须将它们导出来供其他文件导入。和<code>import</code>一样，<code>export</code>也是一个非浏览器的功能。",
        "下面的例子阐述了如何进行一个命名导出。通过这样，我们可以使用上节课学习的<code>import</code>语法，将导出的代码导入到其他的文件中去。请看下面的例子：",
        "<blockquote>const capitalizeString = (string) => {<br>&nbsp;&nbsp;return string.charAt(0).toUpperCase() + string.slice(1);<br>}<br>export { capitalizeString } //如何导出函数。<br>export const foo = \"bar\"; //如何导出变量。</blockquote>",
        "另外，如果你想要将你所有的<code>export</code>语句打包成一行，你可以像下面这个例子一样实现：",
        "<blockquote>const capitalizeString = (string) => {<br>&nbsp;&nbsp;return string.charAt(0).toUpperCase() + string.slice(1);<br>}<br>const foo = \"bar\";<br>export { capitalizeString, foo }</blockquote>",
        "两种方式都是非常棒的实践。",
        "<hr>",
        "下面有两个变量需要在别的文件中可以使用。利用刚才展示的第一种方式，导出两个变量。"
      ],
      "tests": [
        {
          "text": "导出了<code>foo</code>变量。",
          "testString": "getUserInput => assert(getUserInput('index').match(/export\\s+const\\s+foo\\s*=\\s*\"bar\"/g), '导出了<code>foo</code>变量。');"
        },
        {
          "text": "导出了<code>bar</code>变量。",
          "testString": "getUserInput => assert(getUserInput('index').match(/export\\s+const\\s+bar\\s*=\\s*\"foo\"/g), '导出了<code>bar</code>变量。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "\"use strict\";",
            "const foo = \"bar\";",
            "const bar = \"foo\";"
          ],
          "head": [
            "window.exports = function(){};"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8c367417b2b2512b57",
      "title": "Use * to Import Everything from a File",
      "description": [
        "我们还可以用<code>import</code>语法从文件中导入所有的内容。",
        "下面是一个从同目录下的<code>\"math_functions\"</code>文件中导入所有内容的例子：",
        "<blockquote>import * as myMathModule from \"math_functions\";<br>myMathModule.add(2,3);<br>myMathModule.subtract(5,3);</blockquote>",
        "让我们来分析一下这段代码：",
        "<blockquote>import * as object_with_name_of_your_choice from \"file_path_goes_here\"<br>object_with_name_of_your_choice.imported_function</blockquote>",
        "你可以在<code>import * as</code>之后添加任意的名称。这个方法接收到的值是一个对象，你可以使用点表示法来获取对象里具体的值。",
        "<hr>",
        "下面的代码需要从同目录下的<code>\"capitalize_strings\"</code>文件中导入所有内容。使用提供的对象，在当前文件的顶部添加正确的<code>import *</code>语句"
      ],
      "tests": [
        {
          "text": "正确使用<code>import * as</code>语法。",
          "testString": "assert(code.match(/import\\s+\\*\\s+as\\s+[a-zA-Z0-9_$]+\\s+from\\s*\"\\s*capitalize_strings\\s*\"\\s*;/gi), '正确使用<code>import * as</code>语法。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "\"use strict\";"
          ],
          "head": [
            "window.require = function(str) {",
            "if (str === 'capitalize_strings') {",
            "return {",
            "capitalize: str => str.toUpperCase(),",
            "lowercase: str => str.toLowerCase()",
            "}}};"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8c367417b2b2512b58",
      "title": "Create an Export Fallback with export default",
      "description": [
        "在<code>export</code>的课程中，你学习了<dfn>命名导出</dfn>的语法。这让你可以在其他文件中引用一些函数或者变量。",
        "你还需要知道另外一种被称为<dfn>默认导出</dfn>的<code>export</code>的语法。在文件中只有一个值需要导出的时候，你通常会使用这种语法。它也常常用于给文件或者模块创建返回值。",
        "下面是一个简单的<code>export default</code>例子：",
        "<blockquote>export default function add(x,y) {<br>&nbsp;&nbsp;return x + y;<br>}</blockquote>",
        "注意：当使用<code>export default</code>去声明一个文件或者模块的返回值，你在每个文件或者模块中应当只默认导出一个值。特别地，你能将<code>export deafult</code>与<code>var</code>，<code>let</code>与<code>const</code>一起使用。",
        "<hr>",
        "下面的函数应该在这个模块中返回一个值。请添加需要的代码："
      ],
      "tests": [
        {
          "text": "正确的使用<code>export</code>进行返回。",
          "testString": "getUserInput => assert(getUserInput('index').match(/export\\s+default\\s+function\\s+subtract\\(x,y\\)\\s+{return\\s+x\\s-\\s+y;}/g), '正确的使用<code>export</code>进行返回。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "\"use strict\";",
            "function subtract(x,y) {return x - y;}"
          ],
          "head": [
            "window.exports = function(){};"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d7b8d367417b2b2512b59",
      "title": "Import a Default Export",
      "description": [
        "在上一个挑战里，你学会了<code>export default</code>的用法。还有一个重要的点，你可能需要另外一种<code>import</code>的语法来导入默认导出。",
        "在下面的例子里有一个<code>add</code>函数, 它在<code>\"math_functions\"</code>文件里默认被导出。让我们看看来如何导入它：",
        "<blockquote>import add from \"math_functions\";<br>add(5,4); //将会返回 9</blockquote>",
        "这个语法只有一处不同的地方 —— 被导入的<code>add</code>值，并没有被花括号<code>{}</code>所包围。与导出值的方法不同，导入默认导出的写法仅仅只是简单的讲变量名写在<code>import</code>之后。",
        "<hr>",
        "在下面的代码中，请导入在同目录下的<code>\"math_functions\"</code>文件中默认导出的<code>subtract</code>值。"
      ],
      "tests": [
        {
          "text": "正确导入<code>export default</code>方法导出的值。",
          "testString": "getUserInput => assert(getUserInput('index').match(/import\\s+subtract\\s+from\\s+\"math_functions\"/g), '正确导入<code>export default</code>方法导出的值。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "\"use strict\";",
            "subtract(7,4);"
          ],
          "head": [
            "window.require = function(str) {",
            "if (str === 'math_functions') {",
            "return function(a, b) {",
            "return a - b;",
            "}}};"
          ],
          "tail": []
        }
      }
    }
  ]
}
