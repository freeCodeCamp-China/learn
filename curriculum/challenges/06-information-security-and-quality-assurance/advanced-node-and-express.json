{
  "name": "Advanced Node and Express",
  "order": 3,
  "time": "5 hours",
  "helpRoom": "Help",
  "challenges": [
    {
      "id": "5895f700f9fc0f352b528e63",
      "title": "Set up a Template Engine",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "你可以在应用的模版引擎中使用静态模板文件（如那些写在<em>Pug</em>里的）。在运行时，模版引擎会用服务端的真实数据替换掉模版文件中的变量，然后将模版转译成发送给客户端的 HTML 静态文件。这样可以轻松地构造 HTML 页面，允许在页面直接显示变量内容而不需要发送 API 请求。",
        "为了在项目中使用 <em>Pug</em>，你需要在 package.json 中添加依赖<code>\"pug\": \"^0.1.0\"</code>",
        "为了在 Node/Express 中使用 pug 作为模版引擎，你需要在 express 中将 <b>app</b> 的 “view-engine” 设置为 “pug”，就像这样：<code>app.set('view engine', 'pug')</code>。",
        "最后, 你需要使用<code>res.render</code>方法渲染 <em>views/pug/index.pug</em> 页面来作为路由请求的返回。",
        "如果一切顺利，刷新一下应用的主页就可以看到 Pug 成功加载的提示，这时你就可以提交你的页面了。"
      ],
      "tests": [
        {
          "text": "项目中应使用 \"pug\" 作为依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'pug', '项目中应使用 \"pug\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "项目中应使用 Pug 作为模版引擎。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /('|\")view engine('|\"),( |)('|\")pug('|\")/gi, '项目中应使用 Pug 作为模版引擎。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "你的项目主页应使用 pug 作为渲染引擎，且 .pug 文件不应改变。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/') .then(data => { assert.match(data, /pug-success-message/gi, '你的项目主页应使用 pug 作为渲染引擎，且 .pug 文件不应改变。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70bf9fc0f352b528e64",
      "title": "Use a Template Engine's Powers",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "模版引擎最大的特点之一就是在 HTML 页面展示之前，可以从服务端传变量到模版文件。",
        "在 Pug 文件中，你可以用变量名来调用变量，比如写成<code>#{variable_name}</code>来实现行内调用，或像<code>p= variable_name</code>把元素与变量直接写在一起，这表示 p 元素的内容等价于这个变量。",
        "建议大家在 <a href='https://github.com/pugjs/pug'>Pug 的 README</a> 里看看它的语法和用法，这样你写出的代码会相对简练。另外要注意，Pug 使用缩进来表示嵌套的代码块。",
        "在 pug 的 'index.pug' 文件中，我们使用了 <em>title</em> 和 <em>message</em> 两个变量。",
        "为了从服务器传递这些信息，你需要给 <em>res.render</em> 的第二个参数传入一个对象，其中包含变量对应的值。比如，如果你想传递对象<code>{title: 'Hello', message: 'Please login'</code>到你的主页，那么应该这样写：",
        "<code>res.render(process.cwd() + '/views/pug/index', {title: 'Hello', message: 'Please login'});</code>",
        "刷新页面，如果页面中数据显示正确，你就可以提交你的页面了。"
      ],
      "tests": [
        {
          "text": "Pug 应正确地展示变量。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/') .then(data => { assert.match(data, /pug-variable(\"|')>Please login/gi, '你的项目主页应使用 pug 作为渲染引擎，且 .pug 文件不应改变。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70cf9fc0f352b528e65",
      "title": "Set up Passport",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "现在我们来创建 <em>Passport</em>，最终我们需要用它来实现用户注册和登录。除了 Passport，我们会用 express-session 来处理 session（会话）。在客户端，我们可以用这个中间件把会话 id 储存到 cookie，并可以通过服务器上的 id 访问会话数据。通过这种方式，我们可以无需把用户信息存到 cookie 来完成用户的验证。",
        "为了在你的项目中使用 Passport，首先你需要在 package.json 文件中添加依赖：<code>\"passport\": \"^0.3.2\"</code>",
        "此外，还需要添加 express-session 作为依赖，就像这样：<code>\"express-session\": \"^1.15.0\"</code>。express-session 有许多高级特性，但我们暂时只需要了解其基础特性。",
        "现在，我们需要配置 session 并初始化 Passport。请先创建变量<code>session</code>和<code>passport</code>引入 express-session 和 passport。",
        "为了让 express 应用可以使用 session，我们需要添加一些基础选项。请在 .env 文件中添加字段<code>SESSION_SECRET</code>，并给它赋一个随机值，便于加密 cookie、计算哈希。",
        "<pre>app.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: true,\n  saveUninitialized: true,\n}));</pre>",
        "还有，我们需要让 express 使用<code>passport.initialize()</code>和<code>passport.session()</code>。为此，你需要这样写：<code>app.use(passport.initialize());</code>。",
        "完成之后就可以提交你的页面了。如果运行出错，你可以在<a href='https://gist.github.com/JosephLivengood/338a9c5a326923c3826a666d430e65c3'>这里</a>检查项目的完成情况。"
      ],
      "tests": [
        {
          "text": "应添加 Passort 和 express-session 作为依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'passport', '你的项目应该使用 \"passport\" 作为依赖。'); assert.property(packJson.dependencies, 'express-session', '你的项目应该使用 \"express-session\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "依赖应正确引入。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|')passport(\"|')/gi, '你的项目应引入 passport。'); assert.match(data, /require.*(\"|')express-session(\"|')/gi, '你的项目应引入 express-session。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "express 应调用 passport 的方法。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /passport.initialize/gi, 'express 应用应调用 \"passport.initialize()\"。'); assert.match(data, /passport.session/gi, '你的 express 应用应调用 \"passport.session()\"。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应正确设置 session 和 session secret。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /secret:( |)process.env.SESSION_SECRET/gi, '你的 express 应用应设置 express-session 并使用 process.env.SESSION_SECRET。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70cf9fc0f352b528e66",
      "title": "Serialization of a User Object",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "序列化和反序列化在身份认证中是很重要的概念。序列化一个对象就是将其内容转换成一个体积很小的 <em>key</em>，后续可以通过这个 <em>key</em> 反序列化为原始对象。这样，服务器就可以在用户未登录时识别用户，或者说给这个用户一个唯一标识，用户也不需要在每次访问不同页面时都给服务器发送用户名和密码。",
        "我们需要用到序列化和反序列化的方法来进行配置。passport 为我们提供了<code>passport.serializeUser( OURFUNCTION )</code>和<code>passport.deserializeUser( OURFUNCTION )</code>两个方法。",
        "<code>serializeUser</code>方法接收两个参数，分别是表示用户的对象和一个回调函数。其中，回调函数的返回值应为这个用户的唯一标识符：最简单的写法就是让它返回用户的<code>_id</code>，这个<code>_id</code>属性是 MongoDB 为用户创建的唯一字段。类似地，反序列化也接收两个参数，分别是在序列化时生成的标识符以及一个回调函数。在回调函数里，我们需要根据根据传入的标识符（比如 _id）返回表示用户的对象。为了在 MongoDB 中通过 query（查询语句）获取 _id 字段，首先我们需要引入 MongoDB 的<code>ObjectID</code>方法：<code>const ObjectID = require('mongodb').ObjectID;</code>；然后调用它：<code>new ObjectID(THE_ID)</code>。当然，这一切的前提都是先引入 MongoDB 作为依赖。你可以在下面的例子中看到：",
        "<pre>passport.serializeUser((user, done) => {\n   done(null, user._id);\n });</pre><br><pre>passport.deserializeUser((id, done) => {\n        db.collection('users').findOne(\n            {_id: new ObjectID(id)},\n            (err, doc) => {\n                done(null, doc);\n            }\n        );\n    });</pre>",
        "注意：在完全配置好 MongoDB 前，<code>deserializeUser</code>会抛出错误。因此，现在请先注释掉上面的代码，在回调函数中仅仅调用<code>done(null, null)</code>即可。",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应存在正确的<code>serializeUser</code>方法。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /passport.serializeUser/gi, '你应该创建 passport.serializeUser 方法。'); assert.match(data, /null, user._id/gi, 'serializeUser 中应该有一个使用 (null, user._id) 的回调函数。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应存在正确的<code>deserializeUser</code>方法。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /passport.deserializeUser/gi, '你应该创建 passport.deserializeUser 方法。'); assert.match(data, /null,( |)null/gi, 'deserializeUser 中应该有一个使用 (null, user._id) 的回调函数。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "MongoDB 应作为项目的依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'mongodb', '你的项目里应使用 \"mongodb\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "注释掉的代码中应包含<code>ObjectId</code>。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|')mongodb(\"|')/gi, '你应该引入 mongodb。'); assert.match(data, /new ObjectID.*id/gi, '在注释掉的代码块中，添加数据库时应使用 new ObjectID(id)。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70cf9fc0f352b528e67",
      "title": "Implement the Serialization of a Passport User",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "截至目前，我们还没有配置完数据库，因此还无法加载用户数据。实现这个的方式很多，但对于我们的项目，一旦服务器启动，那么只要有 app 实例在运行，数据库就应一直处于连接状态。",
        "为此，我们要添加 MongoDB 作为依赖，并在 server 中<code>require</code>它，就像这样：<code>const mongo = require('mongodb').MongoClient;</code>。",
        "在连接数据库之后，我们才能让服务器开始监听请求，这样做可以保证服务器在数据库连接前或数据库发生错误时不接受任何请求。为此，我们需要这样写：",
        "<pre>mongo.connect(process.env.DATABASE, (err, db) => {\n    if(err) {\n        console.log('Database error: ' + err);\n    } else {\n        console.log('Successful database connection');\n\n        // 序列化和监听请求写在这里\n\n}});</pre>",
        "现在，请把上一个挑战中我们注释掉的<code>deserializeUser</code>中的代码块添加回来，然后删掉<code>done(null, null)</code>。请确保你已经在 .env 文件里配置了<code>DATABASE</code>的数据库连接字段，例如：<code>DATABASE=mongodb://admin:pass@mlab.com:12345/my-project</code>。你可以在 <a href='https://mlab.com/welcome/'>mLab</a> 上创建一个免费的数据库。至此，序列化的创建完成。",
        "完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在<a href=\"https://gist.github.com/JosephLivengood/e192e809a1d27cb80dc2c6d3467b7477\">这里</a>检查你的项目完成情况。"
      ],
      "tests": [
        {
          "text": "应存在数据库连接。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /mongo.connect/gi, '数据库的连接应已创建。'); assert.match(data, /mongo.connect[^]*app.listen[^]*}[^]*}/gi, '应在 mongo.connect 的回调里监听请求。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "反序列化应正确使用，且应移除<code>done(null, null)</code>。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.notMatch(data, /null,( |)null/gi, '包含 done(null, null) 的回调应移除。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70df9fc0f352b528e68",
      "title": "Authentication Strategies",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "现在，我们需要构建验证用户的策略，策略的选择有很多。比如，如果我们已经让用户在注册时填写了用户信息，那我们就可以基于这些信息验证；或者也可以引入第三方登录，如 Google 或者 Github。为此，你可以参考 <a href='http://passportjs.org/'>Passports 中提供的策略插件</a>。对于这个项目的验证策略，我们会采用自己搭建的方式完成。",
        "首先，我们需要引入 <em>passport-local</em> 作为依赖，然后将它添加到服务器，就像这样：<code>const LocalStrategy = require('passport-local');</code>",
        "然后，我们需要让 passport 使用实例化的本地策略对象。请注意，接下来的所有代码都应写在连接数据库的回调中，因为它们的执行都依赖数据库。<pre>passport.use(new LocalStrategy(\n  function(username, password, done) {\n    db.collection('users').findOne({ username: username }, function (err, user) {\n      console.log('User '+ username +' attempted to log in.');\n      if (err) { return done(err); }\n      if (!user) { return done(null, false); }\n      if (password !== user.password) { return done(null, false); }\n      return done(null, user);\n    });\n  }\n));</pre> 这就是我们的用户验证逻辑：首先根据用户输入的用户名在数据库中寻找用户；然后检查密码是否匹配；最后如果没有发生错误，那么就会返回用户对象并通过验证。",
        "我们也可以采用上面链接中提供的验证策略，一般来说，根据该策略仓库中的 README 来进行配置就足够了。一个很好的例子是 Github 策略，在该策略中，我们不需要写用户名或密码的相关验证逻辑，因为用户将被引导到 Github 页面进行验证。只要他们登录并同意，Github 就会返回他们的个人信息供我们使用。",
        "以上就是本次挑战的内容。在下一个挑战中，我们会基于表单数据调用上面写好的验证策略。完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "你的项目需要使用<code>passport-local</code>作为依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'passport-local', '你的项目需要使用 \"passport-local\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应正确地引入和设置<code>passport-local</code>。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|')passport-local(\"|')/gi, '你需要引入 passport-local。'); assert.match(data, /new LocalStrategy/gi, '你需要让 passport 使用新策略 LocalStrategy。'); assert.match(data, /findOne/gi, '新的本地策略需要根据输入的用户名，使用 findOne 方法在数据库中查询。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70df9fc0f352b528e69",
      "title": "How to Use Passport Strategies",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "在提供的 index.pug 文件里有一个登录表单。因为这个表单中存在行内 JavaScript 代码<code>if showLogin</code>，因此它是隐藏的。因为 showLogin 未定义，所以表单不会渲染。如果在该页面的<code>res.render()</code>里添加一个包含<code>showLogin: true</code>的对象，你就可以在刷新页面后看到表单。当你点击 login 时，表单会向服务器的 <em>/login</code> 发送 POST 请求，此时服务器端就可以接受 POST 请求信息并进行用户验证。",
        "在这次挑战中，你需要为 POST 请求添加路由<code>/login</code>。为了用这个路由进行验证，你需要添加一个中间件，中间件应作为参数添加到用于处理请求的回调函数<code>function(req,res)</code>之前。对于 passport 的验证中间件，应这样调用：<code>passport.authenticate('local')</code>。",
        "<em>passport.authenticate</em> 也接收选项作为参数，这些选项用于设置验证，例如<code>{ failureRedirect: '/' }</code>就很有用，请记得添加到你的代码中。如果中间件验证通过，我们就应该提供相应的后续处理。在这个挑战中，我们需要让用户重定到 <em>/profile</em>，这样<code>profile.pug</code>页面就会渲染。",
        "如果验证通过，用户对象将会储存到 <em>req.user</em> 中。",
        "这时，如果你在表单里输入了用户名和密码，路由将会重定向到主页 <em>/</em>，在服务端将会打印 'User {USERNAME} attempted to log in.'，由于现在我们还没有实现注册功能，因此所有登录尝试都会失败。",
        "完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在<a href='https://gist.github.com/JosephLivengood/8a335d1a68ed9170da02bb9d8f5b71d5'>这里</a>检查你的项目完成情况。"
      ],
      "tests": [
        {
          "text": "server.js 中应正确执行所有步骤。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /showLogin:( |)true/gi, '你应该在主页的 render 函数中将变量 \"showLogin\" 设置为 true。'); assert.match(data, /failureRedirect:( |)('|\")\\/('|\")/gi, '你的代码应该包含重定向到 \"/\" 路由的错误处理。'); assert.match(data, /login[^]*post[^]*local/gi, '你应该有一个处理登录的路由，它可以接收 POST 请求，并通过 passport.authenticates 验证。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "到 /login 的 POST 请求应重定向到 /",
          "testString": "getUserInput => $.post(getUserInput('url')+ '/login') .then(data => { assert.match(data, /Looks like this page is being rendered from Pug into HTML!/gi, '由于我们还没有已注册的用户，因此现在尝试登录的请求都应重定向到主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70df9fc0f352b528e6a",
      "title": "Create New Middleware",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "无论是否登录，或者哪怕用户试图访问其他页面，目前都会跳转到<code>/profile</code>。为了解决这个问题，我们需要在 profile 页面渲染之前进行用户验证，创建中间件就可以实现这个功能。",
        "这个挑战的目标是创建<code>ensureAuthenticated(req, res, next)</code>中间件方法，通过在 <em>request</em> 上调用 passports 的<code>isAuthenticated</code>方法，我们可以检查 <em>req.user</em> 是否定义，从而确定用户是否通过认证。如果用户已通过验证，就会调用 <em>next()</em>，否则我们应重定向到主页并让用户登录。该中间件的实现是：",
        "<pre>function ensureAuthenticated(req, res, next) {\n  if (req.isAuthenticated()) {\n      return next();\n  }\n  res.redirect('/');\n};</pre>",
        "然后，我们需要把 <em>ensureAuthenticated</em> 中间件添加到处理请求的回调之前：",
        "<pre>app.route('/profile')\n  .get(ensureAuthenticated, (req,res) => {\n       res.render(process.cwd() + '/views/pug/profile');\n  });</pre>",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "<code>ensureAuthenticated</code>中间件应添加到<code>/profile</code>路由中。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /ensureAuthenticated[^]*req.isAuthenticated/gi, '你应定义 ensureAuthenticated 中间件并调用 req.isAuthenticated 方法。'); assert.match(data, /profile[^]*get[^]*ensureAuthenticated/gi, 'ensureAuthenticated 中间件应在 /profile 路由中。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "如果没有通过验证，对 /profile 的 GET 请求应重定向到 /",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/profile') .then(data => { assert.match(data, /Home page/gi, '如果没有通过验证，尝试访问 profile 页面应重定向回主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "5895f70ef9fc0f352b528e6b",
      "title": "How to Put a Profile Together",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "现在，只有通过验证的用户才能进入 <em>/profile</em> 页面，这样我们就可以在页面上使用 'req.user' 里的信息了。",
        "请在变量中包含 <em>username</em> 键，值为 'req.user.username'，并通过 render 方法传给 profile 页面。然后在 'profile.pug' 页面，添加这行<code>h2.center#welcome Welcome, #{username}!</code>代码来创建类为<code>center</code>、id 为<code>welcome</code>且文本内容为 'Welcome, ' 后加用户名的 h2 元素。",
        "以及，请在 profile 里添加 <em>/logout</em> 链接，后续会用于处理用户退出登录的逻辑：<code>a(href='/logout') Logout</code>",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应在 Pug render 中给 /profile 传一个变量。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /\\/views\\/pug\\/profile[^]*username:( |)req.user.username/gi, '你应该给 profile 页面的 render 方法传一个变量，其中 username 为键，值为 req.user.username。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "58965611f9fc0f352b528e6c",
      "title": "Logging a User Out",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "创建退出登录的逻辑是比较简单的。只要用户尝试退出登录，路由就应重定向到主页，而不应该显示任何其他页面。",
        "在 passport 里，只需要在重定向前调用<code>req.logout();</code>即可完成用户登出。",
        "<pre>app.route('/logout')\n  .get((req, res) => {\n      req.logout();\n      res.redirect('/');\n  });</pre>",
        "你可能注意到我们还没有处理 404 错误，这个错误码代表页面无法找到。在 Node.js 中我们通常会用如下的中间件来处理，请在所有路由之后添加这段代码：",
        "<pre>app.use((req, res, next) => {\n  res.status(404)\n    .type('text')\n    .send('Not Found');\n});</pre>",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应存在退出登录的路由。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /req.logout/gi, '你应该在 /logout 路由里调用 req.logout()'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "退出登录后应重定向到主页 /",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/logout') .then(data => { assert.match(data, /Home page/gi, '当用户退出登录，应重定向到主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "58966a17f9fc0f352b528e6d",
      "title": "Registration of New Users",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "现在我们需要为新用户添加注册帐号的功能，首先我们需要在主页的 res.render 接收的变量对象中添加<code>showRegistration: true</code>。此时刷新页面，你会看到页面上已经显示了我们在 index.pug 文件中定义的注册表单。这个表单设置了请求路径 <em>/register</em>，并将请求方法设置成 <b>POST</b>，所以我们需要在服务器接受 <b>POST</b> 请求，且在数据库中创建用户对象。",
        "用户注册的逻辑如下：注册新用户 > 认证新用户 > 重定向到 /profile。",
        "对于步骤一的注册新用户，详细逻辑如下：用 findOne 命令查询数据库 > 如果返回了用户对象，则表示用户存在，然后返回主页；如果用户未定义且没有报错，则会将包含用户名和密码的用户对象通过<code>insertOne</code>添加到数据库，只要没有报错则会继续下一步：认证新用户——我们已经在 /login 路由的 POST 请求中写好了这部分逻辑。",
        "<pre>app.route('/register')\n  .post((req, res, next) => {\n      db.collection('users').findOne({ username: req.body.username }, function (err, user) {\n          if(err) {\n              next(err);\n          } else if (user) {\n              res.redirect('/');\n          } else {\n              db.collection('users').insertOne(\n                {username: req.body.username,\n                 password: req.body.password},\n                (err, doc) => {\n                    if(err) {\n                        res.redirect('/');\n                    } else {\n                        next(null, user);\n                    }\n                }\n              )\n          }\n      })},\n    passport.authenticate('local', { failureRedirect: '/' }),\n    (req, res, next) => {\n        res.redirect('/profile');\n    }\n);</pre>",
        "完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在<a href='https://gist.github.com/JosephLivengood/6c47bee7df34df9f11820803608071ed'>这里</a>检查你的项目完成情况。"
      ],
      "tests": [
        {
          "text": "注册路由和显示主页。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /showRegistration:( |)true/gi, '你应该给首页的 render 方法传入一个对象，其中 \"showRegistration\" 的值为 true。'); assert.match(data, /register[^]*post[^]*findOne[^]*username:( |)req.body.username/gi, '应有一个可以接收注册用户 POST 请求的路由，它应该调用 findOne 及参数 \"username: req.body.username\" 查询数据库。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "注册功能应可以正常运行。",
          "testString": "getUserInput => $.ajax({url: getUserInput('url')+ '/register',data: {username: 'freeCodeCampTester', password: 'freeCodeCampTester'},crossDomain: true, type: 'POST', xhrFields: { withCredentials: true }}) .then(data => { assert.match(data, /Profile/gi, '用户应可以注册，并在注册成功后跳转到 profile 页。注意，测试失败后，直到测试成功为止，会一直清除数据库。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "登录功能应可以正常运行。",
          "testString": "getUserInput => $.ajax({url: getUserInput('url')+ '/login',data: {username: 'freeCodeCampTester', password: 'freeCodeCampTester'}, type: 'POST', xhrFields: { withCredentials: true }}) .then(data => { assert.match(data, /Profile/gi, '如果之前的测试成功，登录也应该成功且会跳转到 profile 页。注意，在这个测试之后会清除数据库。'); assert.match(data, /freeCodeCampTester/gi, '个人信息页应该正确显示包含用户名的欢迎信息。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "退出登录功能应可以正常运行。",
          "testString": "getUserInput => $.ajax({url: getUserInput('url')+ '/logout', type: 'GET', xhrFields: { withCredentials: true }}) .then(data => { assert.match(data, /Home/gi, '退出登录应重定向至主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "退出登录后，profile 页面应无法访问。",
          "testString": "getUserInput => $.ajax({url: getUserInput('url')+ '/profile', type: 'GET', crossDomain: true, xhrFields: { withCredentials: true }}) .then(data => { assert.match(data, /Home/gi, '退出登录后，尝试访问 profile 页应跳转到主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "58a25c98f9fc0f352b528e7f",
      "title": "Hashing Your Passwords",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "回过头来看信息安全，你也许记得在数据库中存储明文密码是<em>绝对</em>禁止的。现在，我们需要引入 BCrypt 来解决这个问题。",
        "<hr>添加 BCrypt 作为依赖，并通过<code>require</code>添加到服务器代码中。你需要在两个步骤中使用哈希运算：注册和保存新账户，以及登录时检查密码是否正确。",
        "目前处理注册的路由中，我们是这样把密码添加到数据库的：<code>password: req.body.password</code>。我们可以通过这段代码创建哈希值：<code>var hash = bcrypt.hashSync(req.body.password, 12);</code>，然后就可以把<code>passsword: req.body.password</code>替换为<code>password: hash</code>。",
        "最后，在验证逻辑中，我们已经有这样一段代码执行检查：<code>if (password !== user.password) { return done(null, false); }</code>。但我们现在存储的密码<code>user.password</code>已经是哈希值了。由于目前的检测机制是密码不匹配时就返回未认证，因此修改后，用于比对用户密码哈希值的代码应该是这样：<code>if (!bcrypt.compareSync(password, user.password)) { return done(null, false); }</code>。",
        "当你需要存储密码时，这样做可以有效地提升网站的安全性。完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应存在 BCrypt 依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'bcrypt', '你的项目应该将 \"bcrypt\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "BCrypt 应正确地引入和调用。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|')bcrypt(\"|')/gi, '应正确引用 BCrypt。'); assert.match(data, /bcrypt.hashSync/gi, '应在注册时对密码进行哈希运算。'); assert.match(data, /bcrypt.compareSync/gi, '应在验证逻辑中比较密码的哈希值。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589690e6f9fc0f352b528e6e",
      "title": "Clean Up Your Project with Modules",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-advancednode/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-advancednode/'>GitHub</a> 上克隆。",
        "目前，我们把所有的代码都放到了 server.js 文件里，这会导致代码难以维护，且扩展性差。",
        "现在让我们来创建两个新文件：routes.js 和 auth.js。",
        "在每个文件的开头，我们都需要写上这段代码：<pre>module.exports = function (app, db) {\n\n\n}</pre>",
        "然后，在 server.js 文件的开头，我们需要像这样引入文件：<code>const routes = require('./routes.js');</code>",
        "在成功连接数据库之后，我们需要像这样进行实例化：<code>routes(app, db)</code>。",
        "最后，我们需要把所有路由相关的代码从 server.js 移动到新文件 routes.js。不要忘了，<code>ensureAuthenticated</code>方法的定义也要移动到新文件中，这个是我们在之前的挑战中，为在路由中判断用户是否已登录创建的函数。然后，我们还需要在 routes.js 文件开头添加所需要的依赖，如：<code>const passport = require('passport');</code>。",
        "如果在这些步骤后没有报错，那么恭喜你，你已成功地从 server.js 文件中分离出了路由文件。",
        "现在，我们来把 server.js 中与验证相关的代码分离到 auth.js 中，例如序列化，设置验证策略等。请正确添加依赖，并在 server.js 中调用<code>auth(app,db)</code>。另外，由于我们的注册路由依赖 passport，所以我们需要先调用<code>auth(app, db)</code>，再调用<code>routes(app, db)</code>。",
        "Node 和 Express 高级课程至此就告一段落了，你可以在此基础上继续优化和完善这个项目。但至少，现在你也有一些可以展示给大家看的代码了。完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://glitch.com/#!/project/delicious-herring'>here</a> 这里检查你的项目完成情况。"
      ],
      "tests": [
        {
          "text": "应正确引入新文件。",
          "testString":
              "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|').\\/routes.js(\"|')/gi, '应正确引入新文件。'); assert.match(data, /mongo.connect[^]*routes/gi, '应在连接数据库后调用 routes 的模块。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589a69f5f9fc0f352b528e70",
      "title": "Implementation of Social Authentication",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socialauth/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "第三方用户验证的实现逻辑如下：<ol><li>在用户点击按钮或者链接后，进入验证页面，通过第三方平台（如 GitHub）来进行用户验证。</li><li>需要在路由中调用<code>passport.authenticate('github')</code>，跳转至 GitHub 验证页面。</li><li>页面跳转到 GitHub 上，如果用户未登录 GitHub，就需要在这里进行登录。登录成功后，会出现向用户申请访问权限的确认页。</li><li>如果用户同意访问，则用户会回到我们提供的回调地址，带着 GitHub 那边提供的用户信息回到我们的 app 中。</li><li>验证已完成。在我们的应用中，我们需要查询这个用户是否已经存在。如果是新用户，那我们需要把他的用户信息存储到数据库。</li></ol>",
        "在 OAuth 验证策略中，我们至少需要提供 <em>Client ID</em> 和 <em>Client Secret</em>，这样第三方平台就会获悉验证请求的来源，以及这个来源是否有效。为此，需要去我们使用的第三方验证平台（比如 GitHub）获取这两个字段的值。注意，我们获取到的这个值是唯一的，且仅对我们的当前 app 有效——<b>因此，千万不要分享给别人</b>，更不要上传到公共仓库或者直接写在代码里。通常，我们会在 <em>.env</em> 文件里配置，并在 Node.js 里通过：<code>process.env.GITHUB_CLIENT_ID</code>获取。对于这次挑战，我们将会使用 GitHub 作为验证平台。",
        "首先，你需要进入账户设置里的 <a href='https://github.com/settings/developers'>Developer settings</a>板块，然后在 OAuth Apps 获取 <em>Client ID</em> 和 <em>Client Secret</em>。点击 'Register a new application'，设置你的应用名称，然后把你的 glitch 主页地址（<b>注意，不是项目代码的地址</b>）粘贴到 Homepage URL。然后，回调 url 需要设置成上面 Homepage URL 里你粘贴的地址，但后面要加上 '/auth/github/callback'。这样在用户通过 Github 验证后才能跳转到我们指定的页面。别忘了，我们还需要在 .env 文件里配置好 'GITHUB_CLIENT_ID' 和 'GITHUB_CLIENT_SECRET'。",
        "然后，请在你现在的项目里，为 /auth/github 和 /auth/github/callback 创建两个接收 GET 请求的路由。第一个只需要通过 passport 来调用 'github' 验证，第二个需要调用 passport 来验证 'github'，但需要在失败时跳转回主页 '/'，成功是跳转到用户页面 '/profile'。跳转的逻辑与上一个项目中的逻辑一样。",
        "例如 '/auth/github/callback' 应该像我们处理在上一个项目中一般的登录一样：<pre>app.route('/login')\n  .post(passport.authenticate('local', { failureRedirect: '/' }), (req,res) => { \n    res.redirect('/profile'); \n  });</pre>",
        "完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在<a href='https://gist.github.com/JosephLivengood/28ea2cae7e1dc6a53d7f0c42d987313b'>这里</a>检查你的项目完成情况。"
      ],
      "tests": [
        {
          "text": "路由 /auth/github 应正确配置。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /('|\")\\/auth\\/github('|\")[^]*get.*passport.authenticate.*github/gi, '路由 auth/github 应只调用 passport.authenticate 和 github。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "路由 /auth/github/callback 应正确配置。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /('|\")\\/auth\\/github\\/callback('|\")[^]*get.*passport.authenticate.*github.*failureRedirect:( |)(\"|')\\/(\"|')/gi, '路由 auth/github/callback 应该接收 GET 请求，且调用 passport.authenticate。验证失败时应跳转回主页。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589a69f5f9fc0f352b528e71",
      "title": "Implementation of Social Authentication II",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socialauth/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "设置 GitHub 验证的最后一步是创建策略本身。为此，你需要在项目中<code>require</code>'passport-github'，且实例化为 GithubStrategy：<code>const GitHubStrategy = require('passport-github').Strategy;</code>。",
        "为了设置 GitHub 策略，我们需要在 <b>passport</b> 中使用实例化的 <b>GithubStrategy</b>，它可以接收两个参数：一个对象（包括 <em>clientID</em>, <em>clientSecret</em> 和 <em>callbackURL</em>），以及一个回调函数。在这个回调函数中，我们要处理验证成功时，判断用户是否已经在数据库中存在的逻辑，还有如果数据库中不存在，把用户数据添加到数据库的代码。这种处理方式适用于绝大部分第三方验证策略，但有些策略会需要我们提供更多的信息，详情请参考相关策略的 README。例如，Google 的验证策略会要求你提供一个 <em>scope</em>，用于标示用户成功登录后，你需要从返回的对象中获取那些信息。以及，这也需要经过用户同意，你才可以获取到。当前我们使用的验证策略，你也可以从它 GitHub 的页面上了解它的用法，不过我们也会在这里进行详细讲解。",
        "你的新策略应该这样去实现：<pre>passport.use(new GitHubStrategy({\n    clientID: process.env.GITHUB_CLIENT_ID,\n    clientSecret: process.env.GITHUB_CLIENT_SECRET,\n    callbackURL: /*INSERT CALLBACK URL ENTERED INTO GITHUB HERE*/\n  },\n  function(accessToken, refreshToken, profile, cb) {\n      console.log(profile);\n      // 在这里写和数据库相关的代码\n  }\n));</pre>",
        "目前，你的验证部分不会成功。由于没有数据库的逻辑和回调函数，你的代码目前还会报错。但如果你试一试，就可以在右边的控制台里看到输出了你的 GitHub 的个人信息。",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应添加依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'passport-github', '你的项目应该有 \"passport-github\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应引入依赖",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /require.*(\"|')passport-github(\"|')/gi, '你应该引入 passport-github'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "到目前为止，Github 策略应正确设置。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /passport.use.*new GitHubStrategy/gi, 'Passport 应该使用新的 GitHubStrategy'); assert.match(data, /callbackURL:( |)(\"|').*(\"|')/gi, '你应该设置一个 callbackURL'); assert.match(data, /process.env.GITHUB_CLIENT_SECRET/g, '你的代码中应包含 process.env.GITHUB_CLIENT_SECRET'); assert.match(data, /process.env.GITHUB_CLIENT_ID/g, '你的代码中应包含 process.env.GITHUB_CLIENT_ID'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589a8eb3f9fc0f352b528e72",
      "title": "Implementation of Social Authentication III",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socialauth/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "验证策略的最后一部分是处理从 GitHub 返回的个人信息。如果用户存在，我们就需要从数据库中读取用户数据并在 profile 页面加载；否则，我们需要把用户信息添加到数据库。GitHub 在用户信息中为我们提供了独一无二的 <em>id</em>，我们可以通过序列化的 id 在数据库中搜索用户（已实现）。以下是这个逻辑的实现示例，我们应该把它传到新策略的第二个参数，就是目前<code>console.log(profile);</code>的下方：",
        "<pre>db.collection('socialusers').findAndModify(\n    {id: profile.id},\n    {},\n    {$setOnInsert:{\n        id: profile.id,\n        name: profile.displayName || 'John Doe',\n        photo: profile.photos[0].value || '',\n        email: profile.emails[0].value || 'No public email',\n        created_on: new Date(),\n        provider: profile.provider || ''\n    },$set:{\n        last_login: new Date()\n    },$inc:{\n        login_count: 1\n    }},\n    {upsert:true, new: true},\n    (err, doc) => {\n        return cb(null, doc.value);\n    }\n);</pre>",
        "<code>findAndModify</code>的作用是在数据库中查询对象并更新，如果对象不存在，我们也可以<code>upsert</code>（注，upsert 可以理解为 update + insert）它，然后我们可以在回调方法里获取到插入数据后的新对象。在这个例子中，我们会把 last_login 设置成为 now，而且总会为 login_count 加 1。只有在插入一个新对象（新用户）时，我们才会初始化这些字段。另外，还需要注意默认值的使用。有时返回的用户信息可能不全，可能是因为用户没有填写，也可能是因为用户选择不公开一部分信息。在这种情况下，我们需要进行相应的处理，以防我们的 app 报错。",
        "你现在应该可以登录你的应用了，试试吧。完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://glitch.com/#!/project/guttural-birch'>here</a> 这里检查这个迷你项目的完成代码。"
      ],
      "tests": [
        {
          "text": "GitHub 策略应配置完成。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /GitHubStrategy[^]*db.collection/gi, '应在当前 GitHub 策略中调用数据库方法，查找用户。'); assert.match(data, /GitHubStrategy[^]*socialusers/gi, '策略应使用 \"socialusers\" collection。'); assert.match(data, /GitHubStrategy[^]*return cb/gi, '策略应返回回调方法 \"cb\"'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc830f9fc0f352b528e74",
      "title": "Set up the Environment",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "现在，我们需要添加 Socket.IO 作为依赖，在你的代码中引入，给它传入参数 http 并实例化，将其命名为<code>io</code>，就像这样：<code>const io = require('socket.io')(http);</code>",
        "我们需要处理的第一件事是监听从客户端发出的连接事件，我们可以调用 <em>on</em> 方法来监听具体的事件。它接收两个参数：一个是发出的事件的标题字符串，另一个是后续用来传递数据的回调函数。在这个回调函数中，我们用 <em>socket</em> 来代表它所包含的数据。简单来说，socket 就是指已连接到服务器的客户端。",
        "在我们服务器代码中，只需要在注释间添加以下内容即可：<pre>io.on('connection', socket => {\n  console.log('A user has connected');\n});</pre>",
        "对于发出连接事件的客户端，只需要在 client.js 中添加以下内容：<pre>/*global io*/\nvar socket = io();</pre>注意，这个 client.js 文件是在用户通过验证后加载到客户端的。在这个文件中，我们没有定义 io 变量，但第一行的注释会阻止运行时产生的报错。然后，我们在 chat.pug 的页面上已经为你添加好了 Socket.IO 库的 CDN。",
        "现在你可以尝试启动你的 app 并登录，你会看到服务器的控制台中打印了 'A user has connected'",
        "<strong>注意：</strong><br>只有在连接到处于同一个 url/server 上的 socket 时，<code>io()</code>才可以正常执行。如果需要连接到外部的 socket，就需要这样调用：<code>io.connect('URL');</code>。",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应添加 Socket.IO 作为依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'socket.io', '你的项目应该添加 \"socket.io\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "Socket.IO 应正确地引入和实例化。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js').then(data => {assert.match(data, /io.*=.*require.*('|\")socket.io('|\").*http/gi, '你应该正确引入 socket.io，并实例化为 io。');}, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "Socket.IO 应监听连接。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /io.on.*('|\")connection('|\").*socket/gi, 'io 应监听 \"connection\"，且 socket 应该作为第二个参数传入 on 方法。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "客户端应连接到服务器。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/public/client.js') .then(data => { assert.match(data, /socket.*=.*io/gi, '客户端应连接到服务器，且连接应定义为 socket'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc831f9fc0f352b528e75",
      "title": "Communicate by Emitting",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "<dfn>Emit</dfn> 是你会用到的，最常见的通信方式。如果我们从服务器发送信息给 'io'，就相当于把事件的名称和数据发送给了所有处于连接状态的 socket。我们可以利用这个特性实现这样的功能：只要有新用户连接到服务器，我们就可以把目前连接的总用户数发给所有已连接的用户，这样所有用户随时都可以看到实时的在线人数。",
        "<hr>首先，我们需要在监听连接的地方之前添加一个用于追踪用户数的变量：<code>var currentUsers = 0;</code>",
        "然后，只要有人连接到服务器，我们需要在发出用户数量之前先给这个变量加 1：<code>++currentUsers;</code>",
        "最后，在监听连接的地方发出（emit）该事件即可。这个事件应命名为 'user count'，且数据应该为 'currentUsers'：<code>io.emit('user count', currentUsers);</code>",
        "<hr>接下来，我们还需要让客户端监听从服务端发出的事件。为此，我们还是需要用到 <em>on</em> 这个方法：<pre>socket.on('user count', function(data){\n  console.log(data);\n});</pre>",
        "现在你可以尝试启动你的 app 并登录，你会看到在客户端的控制台打印出了 1，这就表示目前连接到服务器的用户数为 1。你可以试着通过打开多个 app 来验证数量是否会增加。",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "应定义 currentUsers",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js').then(data => {assert.match(data, /currentUsers/gi, '你应该定义变量 currentUsers');}, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "服务器应在有新的连接时 emit 当前用户数量。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /io.emit.*('|\")user count('|\").*currentUsers/gi, '你应该 emit 带有 currentUsers 数据的 \"user count\" 事件。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "客户端应监听 'user count' 事件。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/public/client.js') .then(data => { assert.match(data, /socket.on.*('|\")user count('|\")/gi, '客户端应通过 socket 连接到服务端，并监听 \"user count\" 事件。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc831f9fc0f352b528e76",
      "title": "Handle a Disconnect",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "你也许注意到，目前为止我们只处理用户数量的增加，没有处理减少。事实上，处理用户断开连接也很简单。区别在于，新连接的监听是发生在整个服务器上，但连接断开的监听是发生在每个 socket 上。",
        "<hr>为此，我们需要在目前的监听回调里面监听 socket 断开连接的事件。在断开连接的回调函数中，我们可以不传任何参数，但你可以在这里添加连接断开的测试代码：<code>socket.on('disconnect', () => { /* 在这里添加连接断开的测试代码 */ });</code>",
        "为确保客户端可以看到实时的用户数量，显然，我们应该在用户断开时让 currentUsers 减 1，然后发送 'user count' 事件，并使用修改后的用户数量。",
        "<strong>注意：</strong><br>和 'disconnect' 类似，所有 socket 可以发送到服务器的事件，我们都应该在有 'socket' 定义的连接监听器里处理。",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "服务器应处理断开 socket 连接的事件。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /socket.on.*('|\")disconnect('|\")/gi, '应监听 disconnect 事件。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "客户端应监听 'user count' 事件。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/public/client.js') .then(data => { assert.match(data, /socket.on.*('|\")user count('|\")/gi, '客户端应使用 socket 变量与服务器建立连接，且应监听 user count 事件。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc831f9fc0f352b528e77",
      "title": "Authentication with Socket.IO",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "目前，我们还无法确定连接到服务器的用户身份。虽然 req.user 包含用户信息，但这个只在用户直接与服务器交互（即不通过 web socket 访问服务器资源）时产正。当我们的用户通过 web socket 与服务器连接时，由于不存在 req 对象，因此我们无法获取用户数据。解决这个问题的方法之一是通过读取和解析请求中包含 passport session 的 cookie，然后反序列化，进而获取用户信息对象。幸运的是，npm 上有可以让这个复杂的流程简单化的库。",
        "<hr>添加 'passport.socketio' 作为依赖，然后赋值给 'passportSocketIo'。",
        "现在我们只需要做一些简单的配置，然后让 Socket.IO 使用它就可以了。请注意，这部分代码应添加在目前的 socket 代码之前，不应添加在目前的连接事件监听中：<pre>io.use(passportSocketIo.authorize({\n  cookieParser: cookieParser,\n  key:          'express.sid',\n  secret:       process.env.SESSION_SECRET,\n  store:        sessionStore\n}));</pre>你也可以为验证设置回调函数，为它传入 'success' 或 'fail'。这个函数会在用户尝试连接并完成验证后调用。",
        "现在，我们可以通过<code>socket.request.user</code>访问用户数据。例如，现在你在代码中添加以下内容：<code>console.log('user ' + socket.request.user.name + ' connected');</code>。这样我们就可以在服务端的控制台打印出通过 socket 连接到服务器的用户信息。",
        "完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://gist.github.com/JosephLivengood/a9e69ff91337500d5171e29324e1ff35'>here</a> 这里检查这个项目的完成代码。"
      ],
      "tests": [
        {
          "text": "应添加 passportSocketIo 作为依赖。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/package.json') .then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'passport.socketio', '应添加 \"passport.socketio\" 作为依赖。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应正确引入 passportSocketIo 并实例化。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js').then(data => { assert.match(data, /require\\((['\"])passport\\.socketio\\1\\)/gi, '应正确引入并实例化 \"passport.socketio\"');}, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "应正确配置 passportSocketIo。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /io\\.use\\(.+\\.authorize\\(/gi, '你应在 socket.io 中间件中使用 \"passport.socketio\"，且正确地配置它。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc832f9fc0f352b528e78",
      "title": "Announce New Users",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "许多聊天室都有这个功能：所有已连接到服务器的在线用户都会看到有人加入或退出的提醒。我们已经写好了处理连接和断开事件的代码，只要对这个方法稍作修改就可以实现这个功能。在事件中，我们需要发送这三条信息：连接或断开的用户名、当前用户数量、事件类型（即需要知道用户究竟是连接还是断开）。",
        "<hr>请将事件名称更改为 'user'，其中应包含如下字段：'name'、'currentUsers'、'connected'（布尔值，对于连接是 true，断开是 false）。记得要修改之前我们写好的处理 'user count' 的那部分代码，现在我们应传入布尔值：<code>io.emit('user', {name: socket.request.user.name, currentUsers, connected: true});</code>",
        "现在，我们的客户端已经有足够的信息显示现有用户数量和发送用户上下线通知。接下来我们需要在客户端监听 'user' 事件，然后使用 jQuery 把<code>#num-users</code>节点的文本内容更新为 '{NUMBER} users online'。同时，我们需要为<code>&#60;ul&#62;</code>添加一个 id 为 'messages' 且带有 '{NAME} has {joined/left} the chat.' 文本的<code>&#60;li&#62;</code>：",
        "<pre>socket.on('user', function(data){\n  $('#num-users').text(data.currentUsers+' users online');\n  var message = data.name;\n  if(data.connected) {\n    message += ' has joined the chat.';\n  } else {\n    message += ' has left the chat.';\n  }\n  $('#messages').append($('&#60;li&#62;').html('&#60;b&#62;'+ message +'&#60;\\/b&#62;'));\n});</pre>",
        "完成上述要求后，你就可以在左边提交你的页面链接。"
      ],
      "tests": [
        {
          "text": "user 事件应发送包含 name、currentUsers、connected 字段的对象。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /io.emit.*('|\")user('|\").*name.*currentUsers.*connected/gi, '应发送名为 user，且包含 name、currentUsers、connected 的事件。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "客户端应处理和显示  'user' 对象中的信息。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/public/client.js') .then(data => { assert.match(data, /socket.on.*('|\")user('|\")[^]*num-users/gi, '应在客户端监听 \"user\" 事件，并在回调函数中改变 #num-users 的文本内容，以此来展示实时的用户连接数量。'); assert.match(data, /socket.on.*('|\")user('|\")[^]*messages.*li/gi, '应在客户端监听 \"user\" 事件，并在回调函数中给 #messages 添加条目，以此来展示用户连接或断开的信息。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    },
    {
      "id": "589fc832f9fc0f352b528e79",
      "title": "Send and Display Chat Messages",
      "description": [
        "注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socketio/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。",
        "现在，我们可以开始实现聊天室功能了。整体逻辑很简单，只需要获取用户发给服务端的消息，再通过服务端给所有客户端发送信息就可以了。在 client.js 文件里，你应该已经注意到了这段提交表单的代码：<code>$('form').submit(function(){ /*logic*/ });</code>",
        "<hr>现在我们需要处理事件的 emit，它应该发生在定义 'messageToSend' 之后，以及清除<code>#m</code>中的文本之前。我们称这个事件叫 'chat message'，需发送的数据叫 'messageToSend'：<code>socket.emit('chat message', messageToSend);</code>",
        "在服务端，我们需要监听包含 'message' 的 'chat message' 事件。一旦事件发生，我们就通过<code>io.emit</code> 把包含 'name' 和 'message' 的 'chat message' 事件发送给所有已连接的 socket。",
        "回到客户端，我们需要监听 'chat message' 事件。只要接收到这个事件，就把包含名字和消息的内容（注意：需要在名字后添加冒号）通过<code>&#60;li&#62;</code>添加到<code>#messages</code>。",
        "至此，我们已经完成发送信息到所有客户端的功能。完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://gist.github.com/JosephLivengood/3e4b7750f6cd42feaa2768458d682136'>这里对应服务端</a> 和 <a href='https://gist.github.com/JosephLivengood/41ba76348df3013b7870dc64861de744'>这里对应客户端</a> 来检查完成代码。"
      ],
      "tests": [
        {
          "text": "服务端应监听 'chat message'，且应在监听到后 emit。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /socket.on.*('|\")chat message('|\")[^]*io.emit.*('|\")chat message('|\").*name.*message/gi, '服务端应监听 \"chat message\" 事件，然后把包含 name 和 message 字段的事件发送给所有已连接的用户。'); }, xhr => { throw new Error(xhr.statusText); })"
        },
        {
          "text": "客户端应正确处理和展示从 'chat message' 事件发来的新数据。",
          "testString": "getUserInput => $.get(getUserInput('url')+ '/public/client.js') .then(data => { assert.match(data, /socket.on.*('|\")chat message('|\")[^]*messages.*li/gi, '应在客户端监听 \"chat message\" 事件，且在回调函数中为 #messages 添加列表项。'); }, xhr => { throw new Error(xhr.statusText); })"
        }
      ],
      "solutions": [],
      "hints": [],
      "challengeType": 2
    }
  ]
}

